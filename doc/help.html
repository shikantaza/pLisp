<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head></head><body>
<center><h1>pLisp Language Reference</h1></center><br/><b><a href="#A">A</a> | </b>
<b><a href="#B">B</a> | </b>
<b><a href="#C">C</a> | </b>
<b><a href="#D">D</a> | </b>
<b><a href="#E">E</a> | </b>
<b><a href="#I">I</a> | </b>
<b><a href="#F">F</a> | </b>
<b><a href="#G">G</a> | </b>
<b><a href="#I">I</a> | </b>
<b><a href="#L">L</a> | </b>
<b><a href="#M">M</a> | </b>
<b><a href="#N">N</a> | </b>
<b><a href="#O">O</a> | </b>
<b><a href="#P">P</a> | </b>
<b><a href="#R">R</a> | </b>
<b><a href="#S">S</a> | </b>
<b><a href="#T">T</a> | </b>
<b><a href="#U">U</a> | </b>
<b><a href="#V">V</a> | </b>
<b><a href="#W">W</a> | </b>
<b><a href="#I">I</a> | </b>
<b><a href="#S">S</a> | </b>
<b><a href="#Non-Alphabetic">Non-Alphabetic</a></b><br/><br/><br/><b><a name="A">A</a></b><br/>
<ul style="padding-left:40px">
<li><a href="#abort">abort</a></li><br/>
<li><a href="#alias">alias</a></li><br/>
<li><a href="#and">and</a></li><br/>
<li><a href="#append">append</a></li><br/>
<li><a href="#apply">apply</a></li><br/>
<li><a href="#array">array</a></li><br/>
<li><a href="#array-eq">array-eq</a></li><br/>
<li><a href="#array-get">array-get</a></li><br/>
<li><a href="#array-length">array-length</a></li><br/>
<li><a href="#array-set">array-set</a></li><br/>
<li><a href="#arrayp">arrayp</a></li><br/>
<li><a href="#aset">aset</a></li><br/>
<li><a href="#assert">assert</a></li><br/>
<li><a href="#assoc">assoc</a></li><br/>
<li><a href="#atom">atom</a></li><br/>
</ul>
<br/><b><a name="B">B</a></b><br/>
<ul style="padding-left:40px">
<li><a href="#break">break</a></li><br/>
<li><a href="#butlast">butlast</a></li><br/>
</ul>
<br/><b><a name="C">C</a></b><br/>
<ul style="padding-left:40px">
<li><a href="#caar">caar</a></li><br/>
<li><a href="#cadar">cadar</a></li><br/>
<li><a href="#cadddr">cadddr</a></li><br/>
<li><a href="#caddr">caddr</a></li><br/>
<li><a href="#cadr">cadr</a></li><br/>
<li><a href="#call-foreign-function">call-foreign-function</a></li><br/>
<li><a href="#call/cc">call/cc</a></li><br/>
<li><a href="#car">car</a></li><br/>
<li><a href="#cdar">cdar</a></li><br/>
<li><a href="#cddr">cddr</a></li><br/>
<li><a href="#cdr">cdr</a></li><br/>
<li><a href="#characterp">characterp</a></li><br/>
<li><a href="#clone">clone</a></li><br/>
<li><a href="#closurep">closurep</a></li><br/>
<li><a href="#concat">concat</a></li><br/>
<li><a href="#concat-strings">concat-strings</a></li><br/>
<li><a href="#cond">cond</a></li><br/>
<li><a href="#cons">cons</a></li><br/>
<li><a href="#cons-pair">cons-pair</a></li><br/>
<li><a href="#consp">consp</a></li><br/>
<li><a href="#continuationp">continuationp</a></li><br/>
<li><a href="#create-image">create-image</a></li><br/>
<li><a href="#create-package">create-package</a></li><br/>
</ul>
<br/><b><a name="D">D</a></b><br/>
<ul style="padding-left:40px">
<li><a href="#define">define</a></li><br/>
<li><a href="#defmacro">defmacro</a></li><br/>
<li><a href="#defun">defun</a></li><br/>
<li><a href="#def-curry-fn">def-curry-fn</a></li><br/>
<li><a href="#dolist">dolist</a></li><br/>
<li><a href="#dotimes">dotimes</a></li><br/>
</ul>
<br/><b><a name="E">E</a></b><br/>
<ul style="padding-left:40px">
<li><a href="#env">env</a></li><br/>
<li><a href="#eq">eq</a></li><br/>
<li><a href="#error">error</a></li><br/>
<li><a href="#eval">eval</a></li><br/>
<li><a href="#exception">exception</a></li><br/>
<li><a href="#expand-macro">expand-macro</a></li><br/>
<li><a href="#export-package">export-package</a></li><br/>
</ul>
<br/><b><a name="I">I</a></b><br/>
<ul style="padding-left:40px">
<li><a href="#import-package">import-package</a></li><br/>
</ul>
<br/><b><a name="F">F</a></b><br/>
<ul style="padding-left:40px">
<li><a href="#fifth">fifth</a></li><br/>
<li><a href="#find">find</a></li><br/>
<li><a href="#find-if">find-if</a></li><br/>
<li><a href="#first">first</a></li><br/>
<li><a href="#flatten">flatten</a></li><br/>
<li><a href="#floatp">floatp</a></li><br/>
<li><a href="#for">for</a></li><br/>
<li><a href="#format">format</a></li><br/>
<li><a href="#fourth">fourth</a></li><br/>
<li><a href="#funcall">funcall</a></li><br/>
</ul>
<br/><b><a name="G">G</a></b><br/>
<ul style="padding-left:40px">
<li><a href="#gensym">gensym</a></li><br/>
</ul>
<br/><b><a name="I">I</a></b><br/>
<ul style="padding-left:40px">
<li><a href="#if">if</a></li><br/>
<li><a href="#in-package">in-package</a></li><br/>
<li><a href="#incf">incf</a></li><br/>
<li><a href="#integerp">integerp</a></li><br/>
</ul>
<br/><b><a name="L">L</a></b><br/>
<ul style="padding-left:40px">
<li><a href="#lambda">lambda</a></li><br/>
<li><a href="#last">last</a></li><br/>
<li><a href="#last-n">last-n</a></li><br/>
<li><a href="#length">length</a></li><br/>
<li><a href="#let">let</a></li><br/>
<li><a href="#let*">let*</a></li><br/>
<li><a href="#letrec">letrec</a></li><br/>
<li><a href="#list">list</a></li><br/>
<li><a href="#listp">listp</a></li><br/>
<li><a href="#load-file">load-file</a></li><br/>
<li><a href="#load-foreign-library">load-foreign-library</a></li><br/>
<li><a href="#load-object">load-object</a></li><br/>
</ul>
<br/><b><a name="M">M</a></b><br/>
<ul style="padding-left:40px">
<li><a href="#macro">macro</a></li><br/>
<li><a href="#macrop">macrop</a></li><br/>
<li><a href="#make-array">make-array</a></li><br/>
<li><a href="#make-string">make-string</a></li><br/>
<li><a href="#map">map</a></li><br/>
<li><a href="#mapcan">mapcan</a></li><br/>
<li><a href="#mapcar">mapcar</a></li><br/>
<li><a href="#max">max</a></li><br/>
<li><a href="#min">min</a></li><br/>
<li><a href="#multiple-value-bind">multiple-value-bind</a></li><br/>
</ul>
<br/><b><a name="N">N</a></b><br/>
<ul style="padding-left:40px">
<li><a href="#nconc">nconc</a></li><br/>
<li><a href="#neq">neq</a></li><br/>
<li><a href="#newline">newline</a></li><br/>
<li><a href="#not">not</a></li><br/>
<li><a href="#nth">nth</a></li><br/>
<li><a href="#null">null</a></li><br/>
<li><a href="#numberp">numberp</a></li><br/>
</ul>
<br/><b><a name="O">O</a></b><br/>
<ul style="padding-left:40px">
<li><a href="#or">or</a></li><br/>
</ul>
<br/><b><a name="P">P</a></b><br/>
<ul style="padding-left:40px">
<li><a href="#pair">pair</a></li><br/>
<li><a href="#print">print</a></li><br/>
<li><a href="#print-string">print-string</a></li><br/>
<li><a href="#println">println</a></li><br/>
<li><a href="#profile">profile</a></li><br/>
<li><a href="#progn">progn</a></li><br/>
</ul>
<br/><b><a name="R">R</a></b><br/>
<ul style="padding-left:40px">
<li><a href="#range">range</a></li><br/>
<li><a href="#read">read</a></li><br/>
<li><a href="#read-character">read-character</a></li><br/>
<li><a href="#read-float">read-float</a></li><br/>
<li><a href="#read-integer">read-integer</a></li><br/>
<li><a href="#read-string">read-string</a></li><br/>
<li><a href="#remove">remove</a></li><br/>
<li><a href="#remove-duplicates">remove-duplicates</a></li><br/>
<li><a href="#remove-if">remove-if</a></li><br/>
<li><a href="#remove-if-not">remove-if-not</a></li><br/>
<li><a href="#remove-last">remove-last</a></li><br/>
<li><a href="#rest">rest</a></li><br/>
<li><a href="#resume">resume</a></li><br/>
<li><a href="#return-from">return-from</a></li><br/>
<li><a href="#reverse">reverse</a></li><br/>
</ul>
<br/><b><a name="S">S</a></b><br/>
<ul style="padding-left:40px">
<li><a href="#save-object">save-object</a></li><br/>
<li><a href="#second">second</a></li><br/>
<li><a href="#select">select</a></li><br/>
<li><a href="#setcar">setcar</a></li><br/>
<li><a href="#setcdr">setcdr</a></li><br/>
<li><a href="#set">set</a></li><br/>
<li><a href="#setq">setq</a></li><br/>
<li><a href="#string">string</a></li><br/>
<li><a href="#string-get">string-get</a></li><br/>
<li><a href="#string-set">string-set</a></li><br/>
<li><a href="#stringp">stringp</a></li><br/>
<li><a href="#sub-array">sub-array</a></li><br/>
<li><a href="#sub-list">sub-list</a></li><br/>
<li><a href="#substring">substring</a></li><br/>
<li><a href="#symbol">symbol</a></li><br/>
<li><a href="#symbol-name">symbol-name</a></li><br/>
<li><a href="#symbol-value">symbol-value</a></li><br/>
<li><a href="#symbolp">symbolp</a></li><br/>
</ul>
<br/><b><a name="T">T</a></b><br/>
<ul style="padding-left:40px">
<li><a href="#third">third</a></li><br/>
<li><a href="#throw">throw</a></li><br/>
<li><a href="#time">time</a></li><br/>
<li><a href="#try">try</a></li><br/>
</ul>
<br/><b><a name="U">U</a></b><br/>
<ul style="padding-left:40px">
<li><a href="#unbind">unbind</a></li><br/>
<li><a href="#unwind-protect">unwind-protect</a></li><br/>
</ul>
<br/><b><a name="V">V</a></b><br/>
<ul style="padding-left:40px">
<li><a href="#values">values</a></li><br/>
</ul>
<br/><b><a name="W">W</a></b><br/>
<ul style="padding-left:40px">
<li><a href="#while">while</a></li><br/>
</ul>
<br/><b><a name="I">I</a></b><br/>
<ul style="padding-left:40px">
<li><a href="#inspect-object">inspect-object</a></li><br/>
</ul>
<br/><b><a name="S">S</a></b><br/>
<ul style="padding-left:40px">
<li><a href="#step">step</a></li><br/>
</ul>
<br/><b><a name="Non-Alphabetic">Non-Alphabetic</a></b><br/>
<ul style="padding-left:40px">
<li><a href="#-">-</a></li><br/>
<li><a href="#,">,</a></li><br/>
<li><a href="#,@">,@</a></li><br/>
<li><a href="#*">*</a></li><br/>
<li><a href="#/">/</a></li><br/>
<li><a href="#`">`</a></li><br/>
<li><a href="#'">'</a></li><br/>
<li><a href="#+">+</a></li><br/>
<li><a href="#<"><</a></li><br/>
<li><a href="#<="><=</a></li><br/>
<li><a href="#>">></a></li><br/>
<li><a href="#>=">>=</a></li><br/>
</ul>
<hr/>
<a name="abort"></a>
<i>Special Operator</i><b> abort</b><br/><br/>
<b>Syntax:</b> (abort) => NIL<br/><br/>
<b>Arguments:</b> None<br/><br/>
<b>Description: abort</b> aborts the evaluation of an expression when in debug mode<br/><br/>
<b>Exceptions: </b>None; an error is raised if abort is invoked when not in debug mode (entered via a <i>break</i>)<br/><br/>
<b>Examples:</b><br/><br/>
<b>See Also:</b> 
<a href="#break">break</a>, <a href="#resume">resume</a><hr/>
<a name="alias"></a>
<i>Macro</i><b> alias</b><br/><br/>
<b>Syntax:</b> (alias var1 var2) => NIL<br/><br/>
<b>Arguments:</b> var1, var2: symbols<br/><br/>
<b>Description: alias</b> creates a new binding between <i>var2</i> and the object bound to <i>var1</i><br/><br/>
<b>Exceptions: </b>Throws an exception of type COMPILE-ERROR if no arguments are supplied. An exception of type INVALID-ARGUMENT is thrown if <i>var1</i> is not a symbol<br/><br/>
<b>Examples:</b><br/><br/>
(define x 100)<br/><br/>(alias y x)<br/><br/>y=>100<br/><br/><b>See Also:</b> 
<a href="#define">define</a><hr/>
<a name="and"></a>
<i>Macro</i><b> and</b><br/><br/>
<b>Syntax:</b> (and form*) => result<br/><br/>
<b>Arguments:</b> form: an object; result: T or NIL<br/><br/>
<b>Description: and</b> performs a logical conjunction of its operands. Returns T if all the operands evaluate to non-NIL and NIL otherwise. Returns T if no arguments are passed<br/><br/>
<b>Exceptions: </b>None<br/><br/>
<b>Examples:</b><br/><br/>
(and (eq 1 1) (eq 2 2)) => T<br/><br/>(and () 3) => NIL<br/><br/><b>See Also:</b> 
<a href="#or">or</a><hr/>
<a name="append"></a>
<i>Function</i><b> append</b><br/><br/>
<b>Syntax:</b> (append list1 list2) => result<br/><br/>
<b>Arguments:</b> list1, list2: forms that evaluate to lists; result: a list<br/><br/>
<b>Description: append</b> creates a new list by appending the two lists passed as arguments<br/><br/>
<b>Exceptions: </b>Throws an exception of type COMPILE-ERROR if the required number of argument are not supplied, and an exception of type EXCEPTION if either of the arguments is not a list<br/><br/>
<b>Examples:</b><br/><br/>
(append '(a b) '(c d)) => (A B C D)<br/><br/>(append () '(1 2)) => (1 2)<br/><br/><b>See Also:</b> 
<a href="#concat">concat</a>, <a href="#nconc">nconc</a><hr/>
<a name="apply"></a>
<i>Special Operator</i><b> apply</b><br/><br/>
<b>Syntax:</b> (apply function args) => result<br/><br/>
<b>Arguments:</b> function: a form that evaluates to a function or a continuation; args: a form that evaluates to a list; result: an object<br/><br/>
<b>Description: apply</b> applies the function or continuation passed as its first parameter to the arguments passed as its second parameter<br/><br/>
<b>Exceptions: </b>Throws an exception of type COMPILE-ERROR if two arguments are not passed; throws an exception of type INVALID-ARGUMENT if the first argument is not a function or a continuation or if the second argument is not a list<br/><br/>
<b>Examples:</b><br/><br/>
(apply (lambda (a b) (+ a b)) '(1 2)) => 3<br/><br/><b>See Also:</b> 
<a href="#funcall">funcall</a><hr/>
<a name="array"></a>
<i>Macro</i><b> array</b><br/><br/>
<b>Syntax:</b> (array dims default-value) => result<br/><br/>
<b>Arguments:</b> dims: a list; default-value: an object; result: an array object<br/><br/>
<b>Description: array</b> creates an array with the dimensions specified by the list <i>dims</i> and populates the elements of the newly-constructed array with <i>default-value</i><br/><br/>
<b>Exceptions: </b>Throws an exception of type COMPILE-ERROR if the required number of argument are not supplied, and INVALID-ARGUMENT if the argument type(s) are not as indicated<br/><br/>
<b>Examples:</b><br/><br/>
(define a (array (2 2) 1)) => [[1 1] [1 1]]<br/><br/><b>See Also:</b> 
<hr/>
<a name="array-eq"></a>
<i>Function</i><b> array-eq</b><br/><br/>
<b>Syntax:</b> (array-eq arr1 arr1) => result<br/><br/>
<b>Arguments:</b> arr1, arr2: forms that evaluate to array objects; result: T or NIL<br/><br/>
<b>Description: array-eq</b> returns T if <i>arr1</i> and <i>arr2</i> are structurally equivalent, i.e. they have the same contents, and NIL otherwise<br/><br/>
<b>Exceptions: </b>Throws an exception of type COMPILE-ERROR if the required number/types of argument are not supplied, and INVALID-ARGUMENT if either of the arguments is not an array<br/><br/>
<b>Examples:</b><br/><br/>
a1 => [1, 2]<br/><br/>a2 => [1, 2]<br/><br/>a3 => ['a 'b]<br/><br/>(array-eq a1 a2) => T<br/><br/>(array-eq a1 a3) => NIL<br/><br/><b>See Also:</b> 
<a href="#eq">eq</a><hr/>
<a name="array-get"></a>
<i>Special Operator</i><b> array-get</b><br/><br/>
<b>Syntax:</b> (array-get arr index) => result<br/><br/>
<b>Arguments:</b> arr: a form that evaluates to an array object; index: a form that evaluates to an integer; result: an object<br/><br/>
<b>Description: array-get</b> returns the object at the position <i>index</i> of array <i>arr</i>. Note that array indices start from zero<br/><br/>
<b>Exceptions: </b>Throws an exception of type COMPILE-ERROR if the required number of arguments are not supplied. Throws an exception of type INVALID-ARGUMENT if the first argument is not an array, and an exception of type INDEX-OUT-OF-BOUNDS if the index is less than zero or greater than <i>(len-1)</i>, where <i>len</i> is the length of the array<br/><br/>
<b>Examples:</b><br/><br/>
a1 => [1, 2]<br/><br/>(array-get a1 0) => 1<br/><br/><b>See Also:</b> 
<a href="#array-set">array-set</a>, <a href="#string-get">string-get</a>, <a href="#string-set">string-set</a><hr/>
<a name="array-length"></a>
<i>Special Operator</i><b> array-length</b><br/><br/>
<b>Syntax:</b> (array-length arr) => result<br/><br/>
<b>Arguments:</b> arr: a form that evaluates to an array object; result: an integer<br/><br/>
<b>Description: array-length</b> returns the length of array <i>arr</i><br/><br/>
<b>Exceptions: </b>Throws an exception of type COMPILE-ERROR if the required number of arguments are not supplied, and an exception of type INVALID-ARGUMENT if the first argument is not an array<br/><br/>
<b>Examples:</b><br/><br/>
a1 => [40, 50]<br/><br/>(array-length a1) => 2<br/><br/><b>See Also:</b> 
<a href="#length">length</a><hr/>
<a name="array-set"></a>
<i>Special Operator</i><b> array-set</b><br/><br/>
<b>Syntax:</b> (array-set arr index form) => form<br/><br/>
<b>Arguments:</b> arr: a form that evaluates to an array object; index: an integer; form: an object<br/><br/>
<b>Description: array-set</b> binds the position <i>index</i> of array <i>arr</i> to <i>form</i><br/><br/>
<b>Exceptions: </b>Throws an exception of type COMPILE-ERROR if the required number of arguments are not supplied. Throws an exception of type INVALID-ARGUMENT if the first argument is not an array, and an exception of type INDEX-OUT-OF-BOUNDS if the index is less than zero or greater than <i>(len-1)</i>, where <i>len</i> is the length of the array<br/><br/>
<b>Examples:</b><br/><br/>
a1 => [40, 50]<br/><br/>(array-set a1 0 30) => 30<br/><br/>a1 => [30, 50]<br/><br/><b>See Also:</b> 
<a href="#array-get">array-get</a>, <a href="#string-get">string-get</a>, <a href="#string-set">string-set</a><hr/>
<a name="arrayp"></a>
<i>Special Operator</i><b> arrayp</b><br/><br/>
<b>Syntax:</b> (arrayp form) => result<br/><br/>
<b>Arguments:</b> form: an object; result: T or NIL<br/><br/>
<b>Description: arrayp</b> returns T if form evaluates to an array and NIL otherwise<br/><br/>
<b>Exceptions: </b>Throws an exception of type COMPILE-ERROR if no arguments are supplied<br/><br/>
<b>Examples:</b><br/><br/>
a1 => [40, 50]<br/><br/>(arrayp a1) => T<br/><br/>(arrayp 10) => NIL<br/><br/><b>See Also:</b> 
<hr/>
<a name="aset"></a>
<i>Macro</i><b> aset</b><br/><br/>
<b>Syntax:</b> (aset ref val) => val<br/><br/>
<b>Arguments:</b> ref: an array reference; val: an object<br/><br/>
<b>Description: aset</b> binds <i>val</i> to the array location referred to by <i>ref</i><br/><br/>
<b>Exceptions: </b>Throws an exception of type SYMBOL-NOT-BOUND if the array reference is not bound to an array object, and an exception INDEX-OUT-OF-BOUNDS if the index(es) in the reference fall outside the array bounds. An exception of type COMPILE-ERROR is thrown if the required number of arguments are not supplied<br/><br/>
<b>Examples:</b><br/><br/>
(define a (array (2 2) 0) => [[0 0] [0 0]]<br/><br/>a => [[0 0] [0 0]]<br/><br/>(aset a[0 0] 100) => 100<br/><br/>a => [[100 0] [0 0]]<br/><br/><b>See Also:</b> 
<hr/>
<a name="assert"></a>
<i>Macro</i><b> assert</b><br/><br/>
<b>Syntax:</b> (assert form) => NIL<br/><br/>
<b>Arguments:</b> form: an object<br/><br/>
<b>Description: assert</b> throws an exception of type EXCEPTION if form evaluates to NIL<br/><br/>
<b>Exceptions: </b>Throws an exception of type COMPILE-ERROR if the no arguments are supplied<br/><br/>
<b>Examples:</b><br/><br/>
<b>See Also:</b> 
<hr/>
<a name="assoc"></a>
<i>Function</i><b> assoc</b><br/><br/>
<b>Syntax:</b> (assoc key pairs) => result<br/><br/>
<b>Arguments:</b> key: an object; pairs: a list of CONS objects; result: object<br/><br/>
<b>Description: assoc</b> returns the CDR of the pair in <i>pairs</i> whose CAR equals <i>key</i> and NIL otherwise<br/><br/>
<b>Exceptions: </b>Throws an exception of type COMPILE-ERROR if the required number of arguments are not supplied. Throws an exception of type EXCEPTION if <i>pairs</i> is not a list of CONS objects<br/><br/>
<b>Examples:</b><br/><br/>
a => ((1 . x) (2 . y))<br/><br/>(assoc 1 a) => x<br/><br/>(assoc 3 a) => NIL<br/><br/><b>See Also:</b> 
<hr/>
<a name="atom"></a>
<i>Special Operator</i><b> atom</b><br/><br/>
<b>Syntax:</b> (atom form) => result<br/><br/>
<b>Arguments:</b> form: an object; result: T or NIL<br/><br/>
<b>Description: atom</b> returns T if <i>form</i> is an atom and NIL otherwise<br/><br/>
<b>Exceptions: </b>Throws an exception of type COMPILE-ERROR if no arguments are supplied<br/><br/>
<b>Examples:</b><br/><br/>
(atom 1) => T<br/><br/>(atom '(1 2)) => NIL<br/><br/><b>See Also:</b> 
<hr/>
<a name="break"></a>
<i>Special Operator</i><b> break</b><br/><br/>
<b>Syntax:</b> (break) => NIL<br/><br/>
<b>Arguments:</b> None<br/><br/>
<b>Description: break</b> stops the evaluation of the expression and passes control to the debugger<br/><br/>
<b>Exceptions: </b>None<br/><br/>
<b>Examples:</b><br/><br/>
<b>See Also:</b> 
<a href="#abort">abort</a>, <a href="#resume">resume</a><hr/>
<a name="butlast"></a>
<i>Function</i><b> butlast</b><br/><br/>
<b>Syntax:</b> (butlast lst len) => result<br/><br/>
<b>Arguments:</b> lst: a form that evaluates to a list; len: an integer; result: a list<br/><br/>
<b>Description: butlast</b> returns a list that comprises the elements of <i>lst</i> excluding the last <i>len</i> elements<br/><br/>
<b>Exceptions: </b>Throws an exception of type COMPILE-ERROR if the required number of arguments are not supplied. Throws an exception of type EXCEPTION if lst is not a list or len is not a positive integer smaller than the length of lst<br/><br/>
<b>Examples:</b><br/><br/>
(butlast '(1 2 3) 1) => (1 2)<br/><br/><b>See Also:</b> 
<a href="#last">last</a>, <a href="#last-n">last-n</a><hr/>
<a name="caar"></a>
<i>Function</i><b> caar</b><br/><br/>
<b>Syntax:</b> (caar lst) => result<br/><br/>
<b>Arguments:</b> lst: a form that evaluates to a list; result: an object<br/><br/>
<b>Description: caar</b> is functionally equivalent to (car (car lst)<br/><br/>
<b>Exceptions: </b>Throws an exception of type COMPILE-ERROR if no arguments are supplied. Throws an exception of type EXCEPTION if either of the applications of car above is not on a list<br/><br/>
<b>Examples:</b><br/><br/>
(caar '((1 2) (3 4)) => 1<br/><br/><b>See Also:</b> 
<a href="#cadar">cadar</a>, <a href="#cadddr">cadddr</a>, <a href="#caddr">caddr</a>, <a href="#cadr">cadr</a>, <a href="#car">car</a>, <a href="#cdar">cdar</a>, <a href="#cddr">cddr</a>, <a href="#cdr">cdr</a>, <a href="#first">first</a>, <a href="#second">second</a>, <a href="#third">third</a>, <a href="#fourth">fourth</a>, <a href="#fifth">fifth</a><hr/>
<a name="cadar"></a>
<i>Function</i><b> cadar</b><br/><br/>
<b>Syntax:</b> (cadar lst) => result<br/><br/>
<b>Arguments:</b> lst: a form that evaluates to a list; result: an object<br/><br/>
<b>Description: cadar</b> is functionally equivalent to (car (cdr (car lst))<br/><br/>
<b>Exceptions: </b>Throws an exception of type COMPILE-ERROR if no arguments are supplied. Throws an exception of type EXCEPTION if any of the applications of car or cdr above is not on a list<br/><br/>
<b>Examples:</b><br/><br/>
(cadar '((1 2) (3 4)) => 2<br/><br/><b>See Also:</b> 
<a href="#caar">caar</a>, <a href="#cadddr">cadddr</a>, <a href="#caddr">caddr</a>, <a href="#cadr">cadr</a>, <a href="#car">car</a>, <a href="#cdar">cdar</a>, <a href="#cddr">cddr</a>, <a href="#cdr">cdr</a>, <a href="#first">first</a>, <a href="#second">second</a>, <a href="#third">third</a>, <a href="#fourth">fourth</a>, <a href="#fifth">fifth</a><hr/>
<a name="cadddr"></a>
<i>Function</i><b> cadddr</b><br/><br/>
<b>Syntax:</b> (cadddr lst) => result<br/><br/>
<b>Arguments:</b> lst: a form that evaluates to a list; result: an object<br/><br/>
<b>Description: cadddr</b> is functionally equivalent to (car (cdr (cdr (cdr lst)))), i.e., the fourth element of a list<br/><br/>
<b>Exceptions: </b>Throws an exception of type COMPILE-ERROR if no arguments are supplied. Throws an exception of type EXCEPTION if any of the applications of car or cdr above is not on a list<br/><br/>
<b>Examples:</b><br/><br/>
(cadddr '(1 2 3 4)) => 4<br/><br/><b>See Also:</b> 
<a href="#caar">caar</a>, <a href="#cadar">cadar</a>, <a href="#caddr">caddr</a>, <a href="#cadr">cadr</a>, <a href="#car">car</a>, <a href="#cdar">cdar</a>, <a href="#cddr">cddr</a>, <a href="#cdr">cdr</a>, <a href="#first">first</a>, <a href="#second">second</a>, <a href="#third">third</a>, <a href="#fourth">fourth</a>, <a href="#fifth">fifth</a><hr/>
<a name="caddr"></a>
<i>Function</i><b> caddr</b><br/><br/>
<b>Syntax:</b> (caddr lst) => result<br/><br/>
<b>Arguments:</b> lst: a form that evaluates to a list; result: an object<br/><br/>
<b>Description: caddr</b> is functionally equivalent to (car (cdr (cdr lst))), i.e., the third element of a list<br/><br/>
<b>Exceptions: </b>Throws an exception of type COMPILE-ERROR if no arguments are supplied. Throws an exception of type EXCEPTION if any of the applications of car or cdr above is not on a list<br/><br/>
<b>Examples:</b><br/><br/>
(caddr '(1 2 3 4)) => 3<br/><br/><b>See Also:</b> 
<a href="#caar">caar</a>, <a href="#cadar">cadar</a>, <a href="#cadddr">cadddr</a>, <a href="#cadr">cadr</a>, <a href="#car">car</a>, <a href="#cdar">cdar</a>, <a href="#cddr">cddr</a>, <a href="#cdr">cdr</a>, <a href="#first">first</a>, <a href="#second">second</a>, <a href="#third">third</a>, <a href="#fourth">fourth</a>, <a href="#fifth">fifth</a><hr/>
<a name="cadr"></a>
<i>Function</i><b> cadr</b><br/><br/>
<b>Syntax:</b> (cadr lst) => result<br/><br/>
<b>Arguments:</b> lst: a form that evaluates to a list; result: an object<br/><br/>
<b>Description: cadr</b> is functionally equivalent to (car (cdr lst)), i.e., the second element of a list<br/><br/>
<b>Exceptions: </b>Throws an exception of type COMPILE-ERROR if no arguments are supplied. Throws an exception of type EXCEPTION if either of the applications of car or cdr above is not on a list<br/><br/>
<b>Examples:</b><br/><br/>
(cadr '(1 2 3 4)) => 2<br/><br/><b>See Also:</b> 
<a href="#caar">caar</a>, <a href="#cadar">cadar</a>, <a href="#cadddr">cadddr</a>, <a href="#caddr">caddr</a>, <a href="#car">car</a>, <a href="#cdar">cdar</a>, <a href="#cddr">cddr</a>, <a href="#cdr">cdr</a>, <a href="#first">first</a>, <a href="#second">second</a>, <a href="#third">third</a>, <a href="#fourth">fourth</a>, <a href="#fifth">fifth</a><hr/>
<a name="call-foreign-function"></a>
<i>Macro</i><b> call-foreign-function</b><br/><br/>
<b>Syntax:</b> (call-foreign-function name return-type params) => result<br/><br/>
<b>Arguments:</b> name: a form that evaluates to a string; return-type: a symbol; params: a list of CONS objects; result: an object<br/><br/>
<b>Description: call-foreign-function</b> invokes a native function called name defined in a shared library that was loaded earlier. <i>return-type</i> denotes the return type of the native function (void, integer, float, character, or character-pointer). <i>params</i> contains information about the parameters to the native function (parameter type and object)<br/><br/>
<b>Exceptions: </b>call-foreign-function throws an exception of type COMPILE-ERROR if the required number of arguments is not supplied.  It throws an exception of type ARG-MISMATCH if the parameters are not of the types as described above. ARG-MISMATCH is also thrown if there are any inconsistencies in the params argument (e.g. the parameter type is integer and the object is not an integer)<br/><br/>
<b>Examples:</b><br/><br/>
(call-foreign-function some_func void ((ivar integer, fvar float)))<br/><br/><b>See Also:</b> 
<a href="#load-foreign-library">load-foreign-library</a><hr/>
<a name="call/cc"></a>
<i>Special Operator</i><b> call/cc</b><br/><br/>
<b>Syntax:</b> (call/cc lambda-exp) => result<br/><br/>
<b>Arguments:</b> lambda-exp: a form; result: an object<br/><br/>
<b>Description: call/cc</b> captures the current continuation object and invokes the function object <i>lambda-exp</i> with this continuation object as the parameter<br/><br/>
<b>Exceptions: </b>Throws an exception of type COMPILE-ERROR if no arguments are supplied.<br/><br/>
<b>Examples:</b><br/><br/>
(call/cc (lambda (cc) (set cont cc)))<br/><br/><b>See Also:</b> 
<hr/>
<a name="car"></a>
<i>Special Operator</i><b> car</b><br/><br/>
<b>Syntax:</b> (car lst) => result<br/><br/>
<b>Arguments:</b> lst: a form that evaluates to a list; result: an object<br/><br/>
<b>Description: car</b> returns the first element of a list<br/><br/>
<b>Exceptions: </b>Throws an exception of type COMPILE-ERROR if no arguments are supplied. Throws an exception of type NOT-A-CONS if the argument is not a list<br/><br/>
<b>Examples:</b><br/><br/>
(car '(1 2 3 4)) => 1<br/><br/>(car nil) => NIL<br/><br/><b>See Also:</b> 
<a href="#caar">caar</a>, <a href="#cadar">cadar</a>, <a href="#cadddr">cadddr</a>, <a href="#caddr">caddr</a>, <a href="#cadr">cadr</a>, <a href="#cdar">cdar</a>, <a href="#cddr">cddr</a>, <a href="#cdr">cdr</a>, <a href="#first">first</a>, <a href="#second">second</a>, <a href="#third">third</a>, <a href="#fourth">fourth</a>, <a href="#fifth">fifth</a><hr/>
<a name="cdar"></a>
<i>Function</i><b> cdar</b><br/><br/>
<b>Syntax:</b> (cdar lst) => result<br/><br/>
<b>Arguments:</b> lst: a form that evaluates to a list; result: an object<br/><br/>
<b>Description: cdar</b> is functionally equivalent to (cdr (car lst))<br/><br/>
<b>Exceptions: </b>Throws an exception of type COMPILE-ERROR if no arguments are supplied. Throws an exception of type EXCEPTION if either of the applications of car or cdr above is not on a list<br/><br/>
<b>Examples:</b><br/><br/>
(cdar '((1 2) 3 4)) => (2)<br/><br/><b>See Also:</b> 
<a href="#caar">caar</a>, <a href="#cadar">cadar</a>, <a href="#cadddr">cadddr</a>, <a href="#caddr">caddr</a>, <a href="#cadr">cadr</a>, <a href="#car">car</a>, <a href="#cddr">cddr</a>, <a href="#cdr">cdr</a>, <a href="#first">first</a>, <a href="#second">second</a>, <a href="#third">third</a>, <a href="#fourth">fourth</a>, <a href="#fifth">fifth</a><hr/>
<a name="cddr"></a>
<i>Function</i><b> cddr</b><br/><br/>
<b>Syntax:</b> (cddr lst) => result<br/><br/>
<b>Arguments:</b> lst: a form that evaluates to a list; result: an object<br/><br/>
<b>Description: cddr</b> is functionally equivalent to (cdr (cdr lst))<br/><br/>
<b>Exceptions: </b>Throws an exception of type COMPILE-ERROR if no arguments are supplied. Throws an exception of type EXCEPTION if either of the applications of cdr above is not on a list<br/><br/>
<b>Examples:</b><br/><br/>
(cddr '(1 2 3 4)) => (3 4)<br/><br/><b>See Also:</b> 
<a href="#caar">caar</a>, <a href="#cadar">cadar</a>, <a href="#cadddr">cadddr</a>, <a href="#caddr">caddr</a>, <a href="#cadr">cadr</a>, <a href="#car">car</a>, <a href="#cdar">cdar</a>, <a href="#cdr">cdr</a>, <a href="#first">first</a>, <a href="#second">second</a>, <a href="#third">third</a>, <a href="#fourth">fourth</a>, <a href="#fifth">fifth</a><hr/>
<a name="cdr"></a>
<i>Special Operator</i><b> cdr</b><br/><br/>
<b>Syntax:</b> (cdr lst) => result<br/><br/>
<b>Arguments:</b> lst: a form that evaluates to a list; result: an object<br/><br/>
<b>Description: cdr</b> returns the list comprising the all the elements of <i>lst</i> except the first one<br/><br/>
<b>Exceptions: </b>Throws an exception of type COMPILE-ERROR if no arguments are supplied. Throws an exception of type EXCEPTION if lst is not a list<br/><br/>
<b>Examples:</b><br/><br/>
(cdr '(1 2 3 4)) => (2 3 4)<br/><br/><b>See Also:</b> 
<a href="#caar">caar</a>, <a href="#cadar">cadar</a>, <a href="#cadddr">cadddr</a>, <a href="#caddr">caddr</a>, <a href="#cadr">cadr</a>, <a href="#car">car</a>, <a href="#cdar">cdar</a>, <a href="#cddr">cddr</a>, <a href="#first">first</a>, <a href="#second">second</a>, <a href="#third">third</a>, <a href="#fourth">fourth</a>, <a href="#fifth">fifth</a><hr/>
<a name="characterp"></a>
<i>Special Operator</i><b> characterp</b><br/><br/>
<b>Syntax:</b> (characterp form) => result<br/><br/>
<b>Arguments:</b> form: an object; result: T or NIL<br/><br/>
<b>Description: characterp</b> returns T if <i>form</i> evaluates to a character and NIL otherwise<br/><br/>
<b>Exceptions: </b>Throws an exception of type COMPILE-ERROR if no arguments are supplied<br/><br/>
<b>Examples:</b><br/><br/>
(characterp #\a) => T<br/><br/>(characterp 10) => NIL<br/><br/><b>See Also:</b> 
<hr/>
<a name="clone"></a>
<i>Special Operator</i><b> clone</b><br/><br/>
<b>Syntax:</b> (clone form) => result<br/><br/>
<b>Arguments:</b> form: an object; result: an object<br/><br/>
<b>Description: clone</b> makes a deep copy of the object <i>form</i> evaluates to<br/><br/>
<b>Exceptions: </b>Throws an exception of type COMPILE-ERROR if no arguments are supplied<br/><br/>
<b>Examples:</b><br/><br/>
(clone '(1 2 3)) => (1 2 3)<br/><br/><b>See Also:</b> 
<hr/>
<a name="closurep"></a>
<i>Special Operator</i><b> closurep</b><br/><br/>
<b>Syntax:</b> (closurep form) => result<br/><br/>
<b>Arguments:</b> form: an object; result: T or NIL<br/><br/>
<b>Description: closurep</b> returns T if form evaluates to a function object and NIL otherwise. Note that special operators are not closures<br/><br/>
<b>Exceptions: </b>Throws an exception of type COMPILE-ERROR if no arguments are supplied<br/><br/>
<b>Examples:</b><br/><br/>
(closurep (lambda (x) x)) => T<br/><br/>(defun double (n) (* n 2)) => <function><br/><br/>(closurep double) => T<br/><br/>(closurep 3) => NIL<br/><br/><b>See Also:</b> 
<hr/>
<a name="concat"></a>
<i>Function</i><b> concat</b><br/><br/>
<b>Syntax:</b> (concat lst &rest lists) => result<br/><br/>
<b>Arguments:</b> lst: a list; lists: a list of the rest of the arguments, which are themselves lists<br/><br/>
<b>Description: concat</b> combines the passed lists into a new list<br/><br/>
<b>Exceptions: </b>Throws an exception of type COMPILE-ERROR if no arguments are supplied. An exception of type INVALID-ARGUMENT is thrown if any of its arguments is not a list<br/><br/>
<b>Examples:</b><br/><br/>
(concat '(1 2 3) '(4 5 6) '(7 8 9)) => '(1 2 3 4 5 6 7 8 9)<br/><br/><b>See Also:</b> 
<a href="#append">append</a>, <a href="#concat-strings">concat-strings</a>, <a href="#nconc">nconc</a><hr/>
<a name="concat-strings"></a>
<i>Function</i><b> concat-strings</b><br/><br/>
<b>Syntax:</b> (concat-strings str1 str2) => result<br/><br/>
<b>Arguments:</b> str1, str2: forms that evaluate to strings; result: a string<br/><br/>
<b>Description: concat-strings</b> combines the two strings passed as arguments into a new string<br/><br/>
<b>Exceptions: </b>Throws an exception of type COMPILE-ERROR if the required number of argument are not supplied, and an exception of type INVALID-ARGUMENT if either of the two arguments is not a string<br/><br/>
<b>Examples:</b><br/><br/>
(concat-strings "abc" "def") => "abcdef"<br/><br/><b>See Also:</b> 
<a href="#concat">concat</a><hr/>
<a name="cond"></a>
<i>Macro</i><b> cond</b><br/><br/>
<b>Syntax:</b> (cond ((cond1 action1) (cond2 action2) ..)) => result<br/><br/>
<b>Arguments:</b> cond1, cond2, …: forms; action1, action2, …: forms; result: an object<br/><br/>
<b>Description: cond</b> takes a list comprising condition/action pairs, and evaluates each condition sequentially, stopping at the first condition that evaluates to a non-NIL value. It then evaluates the action corresponding to this condition and returns the result of evaluating that action. If none of the conditions evaluates to a non-NIL value, cond returns NIL. If the last condition is T, the action corresponding to this serves as the default action<br/><br/>
<b>Exceptions: </b>Throws an exception of type COMPILE-ERROR if the required number of argument are not supplied<br/><br/>
<b>Examples:</b><br/><br/>
(cond ((eq 1 1) 'true) (t 'false)) => TRUE<br/><br/><b>See Also:</b> 
<a href="#if">if</a><hr/>
<a name="cons"></a>
<i>Special Operator</i><b> cons</b><br/><br/>
<b>Syntax:</b> (cons obj1 obj2) => result<br/><br/>
<b>Arguments:</b> obj1, obj2 : objects; result:a CONS object<br/><br/>
<b>Description: cons</b> creates a CONS object from the two objects passed to it as arguments<br/><br/>
<b>Exceptions: </b>Throws an exception of type COMPILE-ERROR if the required number of argument are not supplied<br/><br/>
<b>Examples:</b><br/><br/>
(cons 1 2) => (1 . 2)<br/><br/>(cons 'a nil) => (A)<br/><br/><b>See Also:</b> 
<hr/>
<a name="cons-pair"></a>
<i>Function</i><b> cons-pair</b><br/><br/>
<b>Syntax:</b> (cons-pair list1 list2) => result<br/><br/>
<b>Arguments:</b> list1, list2: forms that evaluate to lists; result: a list<br/><br/>
<b>Description: cons-pair</b> takes two lists and creates a new list, the elements of which are CONS objects obtained by applying cons on the matched elements of the two lists. If the sizes of the two lists are not the same, the shorter of the two lists is padded with NIL values<br/><br/>
<b>Exceptions: </b>Throws an exception of type COMPILE-ERROR if the required number of argument are not supplied, and an exception of type INVALID-ARGUMENT if either of its arguments is not a list<br/><br/>
<b>Examples:</b><br/><br/>
(cons-pair '(a b) '(1 2)) => ((A . 1) (B . 2))<br/><br/>(cons-pair '(a b c) '(1 2)) => ((A . 1) (B . 2) (C))<br/><br/><b>See Also:</b> 
<a href="#pair">pair</a><hr/>
<a name="consp"></a>
<i>Special Operator</i><b> consp</b><br/><br/>
<b>Syntax:</b> (consp form) => result<br/><br/>
<b>Arguments:</b> form: an object; result: T or NIL<br/><br/>
<b>Description: consp</b> returns T if <i>form</i> evaluates to a CONS object and NIL otherwise<br/><br/>
<b>Exceptions: </b>Throws an exception of type COMPILE-ERROR if no arguments are supplied<br/><br/>
<b>Examples:</b><br/><br/>
(define a (cons 1 2)) => (1 . 2)<br/><br/>(consp a) => T<br/><br/>(consp 10) => NIL<br/><br/><b>See Also:</b> 
<hr/>
<a name="continuationp"></a>
<i>Special Operator</i><b> continuationp</b><br/><br/>
<b>Syntax:</b> (continuationp form) => result<br/><br/>
<b>Arguments:</b> form: an object; result: T or NIL<br/><br/>
<b>Description: continuationp</b> returns T if <i>form</i> evaluates to a continuation object and NIL otherwise<br/><br/>
<b>Exceptions: </b>Throws an exception of type COMPILE-ERROR if no arguments are supplied<br/><br/>
<b>Examples:</b><br/><br/>
(define cont nil) => NIL<br/><br/>(progn (call/cc (lambda (cc) (set cont cc))) (print 1)) =><br/><br/>1<br/><br/>1<br/><br/>(continuationp cont) => T<br/><br/><b>See Also:</b> 
<hr/>
<a name="create-image"></a>
<i>Special Operator</i><b> create-image</b><br/><br/>
<b>Syntax:</b> (create-image file-name) => result<br/><br/>
<b>Arguments:</b> file-name: a string object; result: NIL<br/><br/>
<b>Description: create-image</b> saves the current state of the pLisp system to a file called <i>file-name</i><br/><br/>
<b>Exceptions: </b>Throws an exception of type COMPILE-ERROR if no arguments are passed, and an exception of type INVALID-ARGUMENT if the argument is not a string object<br/><br/>
<b>Examples:</b><br/><br/>
(create-image "plisp.image") => NIL<br/><br/><b>See Also:</b> 
<a href="#load-object">load-object</a>, <a href="#save-object">save-object</a><hr/>
<a name="create-package"></a>
<i>Special Operator</i><b> create-package</b><br/><br/>
<b>Syntax:</b> (create-package package-name) => result<br/><br/>
<b>Arguments:</b> package-name: string; result: string<br/><br/>
<b>Description: create-package</b> creates a new package with the name <i>package-name</i>. It returns the name of the newly-created package<br/><br/>
<b>Exceptions: </b>Throws an exception of type COMPILE-ERROR if no arguments are passed, and an exception of type INVALID-ARGUMENT if the argument is not a string object. An exception of type PACKAGE-ALREADY-EXISTS is thrown if the package with name package-name already exists<br/><br/>
<b>Examples:</b><br/><br/>
(create-package "pkg") => "PKG"<br/><br/><b>See Also:</b> 
<a href="#export-package">export-package</a>, <a href="#in-package">in-package</a>, <a href="#import-package">import-package</a><hr/>
<a name="define"></a>
<i>Special Operator</i><b> define</b><br/><br/>
<b>Syntax:</b> (define var form) => var<br/><br/>
<b>Arguments:</b> var: a symbol; form: a form; result: NIL<br/><br/>
<b>Description: define</b> evaluates <i>form</i> and binds the result of this evaluation to <i>var</i> in the top-level environment<br/><br/>
<b>Exceptions: </b>Throws en exception of type INVALID-ARGUMENT if var is not a symbol<br/><br/>
<b>Examples:</b><br/><br/>
(define x 100) => 100<br/><br/>x => 100<br/><br/><b>See Also:</b> 
<a href="#alias">alias</a><hr/>
<a name="defmacro"></a>
<i>Macro</i><b> defmacro</b><br/><br/>
<b>Syntax:</b> (defmacro name params &rest body) => result<br/><br/>
<b>Arguments:</b> name: symbol; params: list; body: the rest of the arguments converted into a list; result: a macro object<br/><br/>
<b>Description: defmacro</b> creates a macro named <i>name</i> with parameters <i>params</i> and body <i>body</i>. An optional string can be passed after <i>params</i> to document the macro.<br/><br/>
<b>Exceptions: </b>Throws an exception of type COMPILE-ERROR if the required number of parameters is not supplied. Propagates exceptions thrown (if any) by the underlying macro expansion.<br/><br/>
<b>Examples:</b><br/><br/>
(defmacro first (lst) `(car ,lst)) => <macro><br/><br/><b>See Also:</b> 
<a href="#macro">macro</a><hr/>
<a name="defun"></a>
<i>Macro</i><b> defun</b><br/><br/>
<b>Syntax:</b> (defun name params &rest body) => result<br/><br/>
<b>Arguments:</b> name: symbol; params: list; body: the rest of the arguments converted into a list; result: a function object<br/><br/>
<b>Description: defun</b> creates a function named <i>name</i> with parameters <i>params</i> and body <i>body</i>. An optional string can be passed after <i>params</i> to document the function.<br/><br/>
<b>Exceptions: </b>Throws an exception of type COMPILE-ERROR if the required number of parameters is not supplied. Propagates exceptions thrown (if any) by the underlying macro expansion.<br/><br/>
<b>Examples:</b><br/><br/>
(defun double (n) (* n 2)) => <function><br/><br/><b>See Also:</b> 
<a href="#lambda">lambda</a><hr/>
<a name="def-curry-fn"></a>
<i>Macro</i><b> def-curry-fn</b><br/><br/>
<b>Syntax:</b> (def-curry-fn f1 f0 &rest args) => result<br/><br/>
<b>Arguments:</b> f1: a symbol; f0: a function; args: a list of the rest of the arguments; result: a function<br/><br/>
<b>Description: def-curry-fn</b> takes a symbol, a function object and a partial list of the arguments to the function, and binds the symbol to a function object which takes as arguments the remaining list of the arguments of the given function object. The returned function object invokes the given function object with the parameters comprising the partial list and the supplied parameters list<br/><br/>
<b>Exceptions: </b>Throws an exception of type COMPILE-ERROR if at least two arguments are not supplied. An exception of type INVALID-ARGUMENT is thrown if the first argument is not a symbol or if the second argument is not a function object<br/><br/>
<b>Examples:</b><br/><br/>
(defun f (a b c) (+ a b c)) => <function><br/><br/>(def-curry-fn c f 10 20) => <function><br/><br/>(c 30) => 60<br/><br/><b>See Also:</b> 
<hr/>
<a name="dolist"></a>
<i>Macro</i><b> dolist</b><br/><br/>
<b>Syntax:</b> (dolist spec &rest body) => result<br/><br/>
<b>Arguments:</b> spec: a list; body: the rest of the arguments converted into a list; result: an object<br/><br/>
<b>Description: dolist</b> evaluates the code in <i>body</i> for each element in the list specified in the CDR of <i>spec</i>, with the value of the element bound to the symbol specified in the CAR of <i>spec</i>. It returns the result of the last evaluation of <i>body</i><br/><br/>
<b>Exceptions: </b>Throws an exception of type COMPILE-ERROR if the required number of parameters is not supplied. Propagates exceptions thrown (if any) by the underlying macro expansion.<br/><br/>
<b>Examples:</b><br/><br/>
(dolist (x '(1 2 3)) (print x)) =><br/><br/>1<br/><br/>2<br/><br/>3<br/><br/>NIL<br/><br/><b>See Also:</b> 
<hr/>
<a name="dotimes"></a>
<i>Macro</i><b> dotimes</b><br/><br/>
<b>Syntax:</b> (dotimes spec &rest body) => result<br/><br/>
<b>Arguments:</b> spec: a list; body: the rest of the arguments converted into a list; result: an object<br/><br/>
<b>Description: dotimes</b> initializes the variable specified in the CAR of <i>spec</i> to zero, and evaluates <i>body</i> with the variable bound to this value. It then successively increments the variable and evaluates <i>body</i> till the value of the variable exceeds the value specified in the CDR of <i>spec</i>. It returns the value of the last evaluation of <i>body</i><br/><br/>
<b>Exceptions: </b>Throws an exception of type COMPILE-ERROR if the required number of parameters is not supplied. Propagates exceptions thrown (if any) by the underlying macro expansion.<br/><br/>
<b>Examples:</b><br/><br/>
(dotimes (x 3) (print x)) =><br/><br/>0<br/><br/>1<br/><br/>2<br/><br/>NIL<br/><br/><b>See Also:</b> 
<hr/>
<a name="env"></a>
<i>Special Operator</i><b> env</b><br/><br/>
<b>Syntax:</b> (env) => result<br/><br/>
<b>Arguments:</b> result: an object<br/><br/>
<b>Description: env</b> returns a list of all the top-level bindings<br/><br/>
<b>Exceptions: </b>Throws an exception of type COMPILE-ERROR if any arguments are supplied<br/><br/>
<b>Examples:</b><br/><br/>
<b>See Also:</b> 
<a href="#"></a><hr/>
<a name="eq"></a>
<i>Special Operator</i><b> eq</b><br/><br/>
<b>Syntax:</b> (eq form1 form2) => result<br/><br/>
<b>Arguments:</b> form1, form2: forms; result: T or NIL<br/><br/>
<b>Description: eq</b> returns T if <i>form1</i> and <i>form2</i> are structurally equivalent and NIL otherwise<br/><br/>
<b>Exceptions: </b>Throws an exception of type COMPILE-ERROR if the required number of parameters is not supplied<br/><br/>
<b>Examples:</b><br/><br/>
(eq 1 1) => T<br/><br/>(eq '(1 2) '(1 2)) => T<br/><br/>(define x "abc") => "abc"<br/><br/>(eq x "abc") => T<br/><br/>(eq 1 'a) => NIL<br/><br/><b>See Also:</b> 
<a href="#array-eq">array-eq</a><hr/>
<a name="error"></a>
<i>Special Operator</i><b> error</b><br/><br/>
<b>Syntax:</b> (error str) => result<br/><br/>
<b>Arguments:</b> str: form that evaluates to a string; result: NIL<br/><br/>
<b>Description: error</b> creates and throws an exception of type EXCEPTION using <i>str</i><br/><br/>
<b>Exceptions: </b>Throws exception of type EXCEPTION as described above<br/><br/>
<b>Examples:</b><br/><br/>
(error "Divide by zero") => -<br/><br/><b>See Also:</b> 
<a href="#throw">throw</a><hr/>
<a name="eval"></a>
<i>Special Operator</i><b> eval</b><br/><br/>
<b>Syntax:</b> (eval form) => result<br/><br/>
<b>Arguments:</b> form: a form; result: an object<br/><br/>
<b>Description: eval</b> compiles and evaluates the form <i>form</i><br/><br/>
<b>Exceptions: </b>Propagates exceptions thrown (if any) by the compilation and evaluation of the form<br/><br/>
<b>Examples:</b><br/><br/>
(eval '(+ 1 1)) => 2<br/><br/><b>See Also:</b> 
<hr/>
<a name="exception"></a>
<i>Function</i><b> exception</b><br/><br/>
<b>Syntax:</b> (exception sym str) => result<br/><br/>
<b>Arguments:</b> sym: a symbol; str: a string; result: an exception object<br/><br/>
<b>Description: exception</b> creates an exception object from the passed symbol and string and returns it<br/><br/>
<b>Exceptions: </b>Throws an exception of type COMPILE-ERROR if the required number of parameters is not supplied<br/><br/>
<b>Examples:</b><br/><br/>
(exception 'exception "An exception") => (EXCEPTION . "An exception")<br/><br/><b>See Also:</b> 
<a href="#error">error</a><hr/>
<a name="expand-macro"></a>
<i>Special Operator</i><b> expand-macro</b><br/><br/>
<b>Syntax:</b> (expand-macro form) => result<br/><br/>
<b>Arguments:</b> form: a form; result: a form<br/><br/>
<b>Description: expand-macro</b> expands the macro application represented by <i>form</i> and returns the result of this expansion. Note that the expansion is only at the first level, i.e. if the expanded form contains any macros, they will not be expanded<br/><br/>
<b>Exceptions: </b>Throws an exception of type COMPILE-ERROR if the required number of parameters is not supplied<br/><br/>
<b>Examples:</b><br/><br/>
(defmacro first (lst) `(car ,lst)) => <macro><br/><br/>(expand-macro '(first some-list)) => (CAR SOME-LIST)<br/><br/><b>See Also:</b> 
<hr/>
<a name="export-package"></a>
<i>Special Operator</i><b> export-package</b><br/><br/>
<b>Syntax:</b> (export-package package-name str) => NIL<br/><br/>
<b>Arguments:</b> package-name: a form that evaluates to a string; str: a form that evaluates to a string<br/><br/>
<b>Description: export-package</b> writes the contents of the package <i>package-name</i> to the file specified by <i>str</i><br/><br/>
<b>Exceptions: </b>Throws an exception of type COMPILE-ERROR if the required number of parameters is not  passed and an exception of type PACKAGE-NOT-FOUND if <i>package-name</i> does not exist<br/><br/>
<b>Examples:</b><br/><br/>
(export-package "user" "user.lisp") => NIL<br/><br/><b>See Also:</b> 
<a href="#create-package">create-package</a>, <a href="#in-package">in-package</a>, <a href="#import-package">import-package</a><hr/>
<a name="import-package"></a>
<i>Special Operator</i><b> import-package</b><br/><br/>
<b>Syntax:</b> (import-package package-name) => NIL<br/><br/>
<b>Arguments:</b> package-name: a form that evaluates to a string<br/><br/>
<b>Description: import-package</b> makes available the symbols (and their bound values)  of the package <i>package-name</i> to the current package<br/><br/>
<b>Exceptions: </b>Throws an exception of type COMPILE-ERROR if the required number of parameters is not  passed and an exception of type PACKAGE-NOT-FOUND if <i>package-name</i> does not exist. An exception of type EXCEPTION is thrown if a package is attempted to be imported into itself, or if it is attempted to import the CORE package.<br/><br/>
<b>Examples:</b><br/><br/>
(import-package "user") => NIL<br/><br/><b>See Also:</b> 
<a href="#create-package">create-package</a>, <a href="#in-package">in-package</a>, <a href="#export-package">export-package</a><hr/>
<a name="fifth"></a>
<i>Macro</i><b> fifth</b><br/><br/>
<b>Syntax:</b> (fifth lst) => result<br/><br/>
<b>Arguments:</b> lst: a list; result: an object<br/><br/>
<b>Description: fifth</b> returns the fifth element of <i>lst</i><br/><br/>
<b>Exceptions: </b>Throws an exception of type COMPILE-ERROR if the required number of parameters is not supplied. An exception of type NOT-A-CONS is thrown if the argument is not a list<br/><br/>
<b>Examples:</b><br/><br/>
(fifth '(1 2 3 4 5 6)) => 5<br/><br/><b>See Also:</b> 
<a href="#caar">caar</a>, <a href="#cadar">cadar</a>, <a href="#cadddr">cadddr</a>, <a href="#caddr">caddr</a>, <a href="#cadr">cadr</a>, <a href="#car">car</a>, <a href="#cdar">cdar</a>, <a href="#cddr">cddr</a>, <a href="#cdr">cdr</a>, <a href="#first">first</a>, <a href="#second">second</a>, <a href="#third">third</a>, <a href="#fourth">fourth</a><hr/>
<a name="find"></a>
<i>Function</i><b> find</b><br/><br/>
<b>Syntax:</b> (find e lst predicate) => result<br/><br/>
<b>Arguments:</b> e: an object: lst: a list; predicate: a function; result: an object<br/><br/>
<b>Description: find</b> returns the first element of <i>lst</i> for which <i>predicate</i> returns true when applied to that element and <i>e</i> and NIL if no such element is found<br/><br/>
<b>Exceptions: </b>Throws an exception of type COMPILE-ERROR if the required number of parameters is not supplied. An exception of type EXCEPTION is thrown if the second parameter is not a list and the third parameter not a function object<br/><br/>
<b>Examples:</b><br/><br/>
(find 3 '(1 2 3) (lambda (x y) (< x y))) => 1<br/><br/><b>See Also:</b> 
<a href="#find-if">find-if</a>, <a href="#select">select</a><hr/>
<a name="find-if"></a>
<i>Function</i><b> find-if</b><br/><br/>
<b>Syntax:</b> (find-if predicate lst) => result<br/><br/>
<b>Arguments:</b> predicate: a function; lst: a list; result: an object<br/><br/>
<b>Description: find-if</b> returns the first element of <i>lst</i> for which <i>predicate</i> returns true and NIL if no such element is found<br/><br/>
<b>Exceptions: </b>Throws an exception of type COMPILE-ERROR if the required number of parameters is not supplied. An exception of type EXCEPTION is thrown if the first parameter not a function object and the second parameter is not a list<br/><br/>
<b>Examples:</b><br/><br/>
(find-if (lambda (x) (stringp x)) '(1 "abc" 'X)) => "abc"<br/><br/><b>See Also:</b> 
<a href="#find">find</a>, <a href="#select">select</a><hr/>
<a name="first"></a>
<i>Macro</i><b> first</b><br/><br/>
<b>Syntax:</b> (first lst) => result<br/><br/>
<b>Arguments:</b> lst: a list; result: an object<br/><br/>
<b>Description: first</b> returns the first element of a list<br/><br/>
<b>Exceptions: </b>Throws an exception of type COMPILE-ERROR if no parameters are supplied. An exception of type NOT-A-CONS is thrown if <i>lst</i> is not a list<br/><br/>
<b>Examples:</b><br/><br/>
(first '(1 2 3)) => 1<br/><br/>(first ()) => NIL<br/><br/><b>See Also:</b> 
<a href="#caar">caar</a>, <a href="#cadar">cadar</a>, <a href="#cadddr">cadddr</a>, <a href="#caddr">caddr</a>, <a href="#cadr">cadr</a>, <a href="#car">car</a>, <a href="#cdar">cdar</a>, <a href="#cddr">cddr</a>, <a href="#cdr">cdr</a>, <a href="#second">second</a>, <a href="#third">third</a>, <a href="#fourth">fourth</a>, <a href="#fifth">fifth</a><hr/>
<a name="flatten"></a>
<i>Function</i><b> flatten</b><br/><br/>
<b>Syntax:</b> (flatten lst) => result<br/><br/>
<b>Arguments:</b> lst: a list; result: a list<br/><br/>
<b>Description: flatten</b> converts the sublists of <i>lst</i> into individual elements<br/><br/>
<b>Exceptions: </b>Throws an exception of type COMPILE-ERROR if the required number of parameters is not supplied. An exception of type NOT-A-CONS is thrown if <i>lst</i> is not a list<br/><br/>
<b>Examples:</b><br/><br/>
(flatten '((1 2 3) (4 5 6))) => (1 2 3 4 5 6)<br/><br/><b>See Also:</b> 
<hr/>
<a name="floatp"></a>
<i>Special Operator</i><b> floatp</b><br/><br/>
<b>Syntax:</b> (floatp form) => result<br/><br/>
<b>Arguments:</b> form: an object; result: T or NIL<br/><br/>
<b>Description: floatp</b> returns T if <i>form</i> evaluates to a float and NIL otherwise<br/><br/>
<b>Exceptions: </b>Throws an exception of type COMPILE-ERROR if no arguments are supplied<br/><br/>
<b>Examples:</b><br/><br/>
(floatp 3.14) => T<br/><br/>(floatp #\a) => NIL<br/><br/><b>See Also:</b> 
<a href="#integerp">integerp</a>, <a href="#numberp">numberp</a><hr/>
<a name="for"></a>
<i>Macro</i><b> for</b><br/><br/>
<b>Syntax:</b> (for (var init-form cond step-form ret-form) &rest body ) => result<br/><br/>
<b>Arguments:</b> var: symbol; init-form, cond, step-form, ret-form: forms; body: rest of the arguments; result: an object<br/><br/>
<b>Description: for</b> loops through the execution of <i>body</i>, binding <i>var</i> to the value of <i>init-form</i> and updating its value by evaluating <i>step-form</i>. After every execution of <i>body</i>, <i>cond</i> is checked, and execution stops if <i>cond</i> evaluates to NIL. Finally <i>ret-form</i> is evaluated and returned<br/><br/>
<b>Exceptions: </b>Throws an exception of type COMPILE-ERROR if the required number of parameters is not supplied. Propagates exceptions thrown (if any) by the underlying macro expansion<br/><br/>
<b>Examples:</b><br/><br/>
(for (i 0 (< i 3) (incf i) nil) (print i)) =><br/><br/>0<br/><br/>1<br/><br/>2<br/><br/>NIL<br/><br/><b>See Also:</b> 
<a href="#dotimes">dotimes</a><hr/>
<a name="format"></a>
<i>Special Operator</i><b> format</b><br/><br/>
<b>Syntax:</b> (format fd str &rest args) => NIL<br/><br/>
<b>Arguments:</b> fd: an integer; str: a form that evaluates to a string; args: rest of the arguments in list form<br/><br/>
<b>Description: format</b> sends the formatted output specified by the format string <i>str</i> and the arguments to the file specified by the file descriptor <i>fd</i> or to standard output if <i>fd</i> is NIL. The format string is modeled identically to the C format string used in printf and fprintf statements<br/><br/>
<b>Exceptions: </b>Throws an exception of type COMPILE-ERROR if two arguments are not supplied. Throws an exception of type INVALID-ARGUMENT if a) the first argument is neither an integer nor NIL, b) if the second argument is not a string or c) args contains any objects other than integers, floats, characters or strings<br/><br/>
<b>Examples:</b><br/><br/>
(define x 100) => 100<br/><br/>(format nil "%d" x) =><br/><br/>100NIL<br/><br/><b>See Also:</b> 
<hr/>
<a name="fourth"></a>
<i>Macro</i><b> fourth</b><br/><br/>
<b>Syntax:</b> (fourth lst) => result<br/><br/>
<b>Arguments:</b> lst: a list; result: an object<br/><br/>
<b>Description: fourth</b> returns the fourth element of <i>lst</i><br/><br/>
<b>Exceptions: </b>Throws an exception of type COMPILE-ERROR if the required number of parameters is not supplied. An exception of type NOT-A-CONS is thrown if <i>lst</i> is not a list<br/><br/>
<b>Examples:</b><br/><br/>
(fourth '(1 2 3 4 5 6)) => 4<br/><br/><b>See Also:</b> 
<a href="#caar">caar</a>, <a href="#cadar">cadar</a>, <a href="#cadddr">cadddr</a>, <a href="#caddr">caddr</a>, <a href="#cadr">cadr</a>, <a href="#car">car</a>, <a href="#cdar">cdar</a>, <a href="#cddr">cddr</a>, <a href="#cdr">cdr</a>, <a href="#first">first</a>, <a href="#second">second</a>, <a href="#third">third</a>, <a href="#fifth">fifth</a><hr/>
<a name="funcall"></a>
<i>Function</i><b> funcall</b><br/><br/>
<b>Syntax:</b> (funcall function &rest args) => result<br/><br/>
<b>Arguments:</b> function: a form that evaluates to a function or a continuation, args: the rest of the arguments converted into a list; result: an object<br/><br/>
<b>Description: funcall</b> applies the function <i>fn</i> to <i>args</i><br/><br/>
<b>Exceptions: </b>Throws an exception of type COMPILE-ERROR if the required number of parameters is not supplied. An exception of type INVALID-ARGUMENT is thrown if the first parameter is not a function object<br/><br/>
<b>Examples:</b><br/><br/>
(funcall (lambda (x y) (+ x y)) 1 2) => 3<br/><br/><b>See Also:</b> 
<a href="#apply">apply</a><hr/>
<a name="gensym"></a>
<i>Special Operator</i><b> gensym</b><br/><br/>
<b>Syntax:</b> (gensym) => result<br/><br/>
<b>Arguments:</b> result: a symbol<br/><br/>
<b>Description: gensym</b> creates a new symbol that is guaranteed to be unique<br/><br/>
<b>Exceptions: </b>None<br/><br/>
<b>Examples:</b><br/><br/>
(gensym) => #:G00027194<br/><br/><b>See Also:</b> 
<hr/>
<a name="if"></a>
<i>Special Operator</i><b> if</b><br/><br/>
<b>Syntax:</b> (if cond then else) => result<br/><br/>
<b>Arguments:</b> cond, then, else: forms; result: an object<br/><br/>
<b>Description: if</b> evaluates <i>cond</i>, and if <i>cond</i> evaluates to a non-NIL value, evaluates <i>then</i>, otherwise evaluates <i>else</i><br/><br/>
<b>Exceptions: </b>Throws an exception of type COMPILE-ERROR if at least the condition and <i>then</i> parameters are not supplied. Propagates any exception thrown during the evaluation of the <i>then</i> or <i>else</i> forms<br/><br/>
<b>Examples:</b><br/><br/>
(if (> 2 1) 'true 'false) => TRUE<br/><br/><b>See Also:</b> 
<a href="#cond">cond</a><hr/>
<a name="in-package"></a>
<i>Special Operator</i><b> in-package</b><br/><br/>
<b>Syntax:</b> (in-package package-name) => NIL<br/><br/>
<b>Arguments:</b> package-name: a form that evaluates to a string<br/><br/>
<b>Description: in-package</b> sets the current package to <i>package-name</i><br/><br/>
<b>Exceptions: </b>Throws an exception of type COMPILE-ERROR if no parameters are passed. Throws an exception of type ACCESS-VIOLATION if applied to the CORE package. Throws an exception of type PACKAGE-NOT-FOUND if <i>package-name</i> does not exist.<br/><br/>
<b>Examples:</b><br/><br/>
(in-package "some-package") => NIL<br/><br/><b>See Also:</b> 
<a href="#create-package">create-package</a>, <a href="#export-package">export-package</a>, <a href="#import-package">import-package</a><hr/>
<a name="incf"></a>
<i>Macro</i><b> incf</b><br/><br/>
<b>Syntax:</b> (incf var) => result<br/><br/>
<b>Arguments:</b> var: symbol; result: an integer or float<br/><br/>
<b>Description: incf</b> increments <i>var</i> by one<br/><br/>
<b>Exceptions: </b>Throws an exception of type COMPILE-ERROR if no parameters are passed. Throws an exception INVALID-ARGUMENT if <i>var</i> is not a symbol or if it is not bound to an integer or a float<br/><br/>
<b>Examples:</b><br/><br/>
(define x 0) => 0<br/><br/>(incf x) => 1<br/><br/>X => 1<br/><br/><b>See Also:</b> 
<hr/>
<a name="integerp"></a>
<i>Special Operator</i><b> integerp</b><br/><br/>
<b>Syntax:</b> (integerp form) => result<br/><br/>
<b>Arguments:</b> form: an object; result: T or NIL<br/><br/>
<b>Description: integerp</b> returns T if <i>form</i> evaluates to an integer and NIL otherwise<br/><br/>
<b>Exceptions: </b>Throws an exception of type COMPILE-ERROR if no arguments are supplied<br/><br/>
<b>Examples:</b><br/><br/>
(integerp 3) => T<br/><br/>(integerp #\a) => NIL<br/><br/><b>See Also:</b> 
<a href="#floatp">floatp</a>, <a href="#numberp">numberp</a><hr/>
<a name="lambda"></a>
<i>Special Operator</i><b> lambda</b><br/><br/>
<b>Syntax:</b> (lambda params &rest body) => result<br/><br/>
<b>Arguments:</b> params: a list; body: the rest of the arguments converted into a list; result: a function object<br/><br/>
<b>Description: lambda</b> creates a function object with params <i>params</i> and body <i>body</i><br/><br/>
<b>Exceptions: </b>Throws an exception of type COMPILE-ERROR if exactly two arguments are not supplied or if the first argument is not a list<br/><br/>
<b>Examples:</b><br/><br/>
(lambda (n) (* n 2)) => <function><br/><br/><b>See Also:</b> 
<a href="#defun">defun</a><hr/>
<a name="last"></a>
<i>Function</i><b> last</b><br/><br/>
<b>Syntax:</b> (last lst) => result<br/><br/>
<b>Arguments:</b> lst: a list; result: an object<br/><br/>
<b>Description: last</b> returns the last element of <i>lst</i><br/><br/>
<b>Exceptions: </b>Throws an exception of type COMPILE-ERROR if no parameters are supplied. An exception of type NOT-A-CONS is thrown if <i>lst</i> is not a list<br/><br/>
<b>Examples:</b><br/><br/>
(last '(1 2 3)) => 3<br/><br/>(last '()) => NIL<br/><br/><b>See Also:</b> 
<a href="#butlast">butlast</a>, <a href="#last-n">last-n</a><hr/>
<a name="last-n"></a>
<i>Function</i><b> last-n</b><br/><br/>
<b>Syntax:</b> (last-n lst n) => result<br/><br/>
<b>Arguments:</b> lst: a list; n: an integer; result: a list<br/><br/>
<b>Description: last-n</b> returns the last <i>n</i> elements of <i>lst</i><br/><br/>
<b>Exceptions: </b>Throws an exception of type COMPILE-ERROR if the required numbers of parameters is not passed. Throws an exception of type EXCEPTION if <i>lst</i> is not a list and an exception of type INVALID-ARGUMENT if <i>n</i> is not an integer<br/><br/>
<b>Examples:</b><br/><br/>
(last-n '(1 2 3) 2) => (2 3)<br/><br/><b>See Also:</b> 
<a href="#butlast">butlast</a>, <a href="#last">last</a><hr/>
<a name="length"></a>
<i>Function</i><b> length</b><br/><br/>
<b>Syntax:</b> (length lst) => result<br/><br/>
<b>Arguments:</b> lst: a list; result: an integer<br/><br/>
<b>Description: length</b> returns the number of elements in <i>lst</i><br/><br/>
<b>Exceptions: </b>Throws an exception of type COMPILE-ERROR if no arguments are passed, and an exception of type EXCEPTION if <i>lst</i> is not a list<br/><br/>
<b>Examples:</b><br/><br/>
(length '(1 2 3 4 5)) => 5<br/><br/>(length '()) => 0<br/><br/><b>See Also:</b> 
<a href="#array-length">array-length</a><hr/>
<a name="let"></a>
<i>Special Operator</i><b> let</b><br/><br/>
<b>Syntax:</b> (let decls &rest body) => result<br/><br/>
<b>Arguments:</b> decls: a form; body: rest of the arguments converted into a list; result: an object<br/><br/>
<b>Description: let</b> executes <i>body</i> after binding the definitions in <i>decl</i><br/><br/>
<b>Exceptions: </b>Throws an exception of type COMPILER-ERROR if the required number of parameters are not supplied or if the first parameter is not a list of (symbol value) bindings<br/><br/>
<b>Examples:</b><br/><br/>
(let ((x 10) (y 20)) (+ x y)) => 30<br/><br/><b>See Also:</b> 
<a href="#letrec">letrec</a>, <a href="#let*">let*</a><hr/>
<a name="let*"></a>
<i>Macro</i><b> let*</b><br/><br/>
<b>Syntax:</b> (let* decls &rest body) => result<br/><br/>
<b>Arguments:</b> decls: a form; body: rest of the arguments converted into a list; result: an object<br/><br/>
<b>Description: let*</b> executes <i>body</i> after binding the definitions in <i>decl</i>. let* is similar to let, but variables in <i>decl</i> can refer to variables declared earlier<br/><br/>
<b>Exceptions: </b>Throws an exception of type COMPILER-ERROR if the required number of parameters are not supplied or if the first parameter is not a list of (symbol value) bindings<br/><br/>
<b>Examples:</b><br/><br/>
(let* ((x 10) (y (+ x 10))) (+ x y)) => 30<br/><br/><b>See Also:</b> 
<a href="#let">let</a>, <a href="#letrec">letrec</a><hr/>
<a name="letrec"></a>
<i>Special Operator</i><b> letrec</b><br/><br/>
<b>Syntax:</b> (letrec decls &rest body) => result<br/><br/>
<b>Arguments:</b> decls: a form; body: rest of the arguments converted into a list; result: an object<br/><br/>
<b>Description: letrec</b> executes <i>body</i> after binding the definitions in <i>decl</i>; it differs from <i>let</i> in that the bindings can be (mutually) recursive<br/><br/>
<b>Exceptions: </b>Throws an exception of type COMPILER-ERROR if the required number of parameters are not supplied or if the first parameter is not a list of (symbol value) bindings<br/><br/>
<b>Examples:</b><br/><br/>
(letrec ((fact (lambda (n) (if (eq n 0) 1 (* n (fact (- n 1))))))) (fact 10.0)) => 3628800<br/><br/><b>See Also:</b> 
<a href="#let">let</a>, <a href="#let*">let*</a><hr/>
<a name="list"></a>
<i>Special Operator</i><b> list</b><br/><br/>
<b>Syntax:</b> (list &rest elems) => result<br/><br/>
<b>Arguments:</b> elems: arguments converted into a list; result: a list<br/><br/>
<b>Description: list</b> creates a list of the elements in <i>elems</i><br/><br/>
<b>Exceptions: </b>None<br/><br/>
<b>Examples:</b><br/><br/>
(list 'a 'b 'c) => (A B C)<br/><br/><b>See Also:</b> 
<a href="#cons">cons</a><hr/>
<a name="listp"></a>
<i>Special Operator</i><b> listp</b><br/><br/>
<b>Syntax:</b> (listp form) => result<br/><br/>
<b>Arguments:</b> form: an object; result: T or NIL<br/><br/>
<b>Description: listp</b> returns T if <i>form</i> evaluates to a list and NIL otherwise<br/><br/>
<b>Exceptions: </b>Throws an exception of type COMPILE-ERROR if no arguments are supplied<br/><br/>
<b>Examples:</b><br/><br/>
(listp '(1 2 3)) => T<br/><br/>(listp '()) => T<br/><br/>(listp 'a) => NIL<br/><br/><b>See Also:</b> 
<hr/>
<a name="load-file"></a>
<i>Special Operator</i><b> load-file</b><br/><br/>
<b>Syntax:</b> (load-file str) => NIL<br/><br/>
<b>Arguments:</b> str: a form that evaluates to a string<br/><br/>
<b>Description: load-file</b> loads the file named <i>str</i> and evaluates the expressions defined in the file<br/><br/>
<b>Exceptions: </b>Throws an exception of type COMPILE-ERROR if no arguments are supplied. Throws an exception of type INVALID-ARGUMENT if the argument is not a string. Exceptions of type FILE-OPEN-ERROR and FILE-READ-ERROR are thrown if the file cannot be opened or read respectively<br/><br/>
<b>Examples:</b><br/><br/>
(load-file "1.lisp") => NIL<br/><br/><b>See Also:</b> 
<hr/>
<a name="load-foreign-library"></a>
<i>Special Operator</i><b> load-foreign-library</b><br/><br/>
<b>Syntax:</b> (load-foreign-library str) => NIL<br/><br/>
<b>Arguments:</b> str: a form that evaluates to a string<br/><br/>
<b>Description: load-foreign-library</b> loads the shared library file named <i>str</i><br/><br/>
<b>Exceptions: </b>Throws an exception of type COMPILE-ERROR if no arguments are supplied. Throws an exception of type INVALID-ARGUMENT if the argument is not a string. An exception of type EXCEPTION is thrown if the maximum number of foreign libraries that can be loaded is exceeded. An OUT-OF-MEMORY exception is thrown if there is no memory to allocate for the structures internally needed to load the foreign library. An exception of type EXCEPTION is thrown if the shared library is an invalid file<br/><br/>
<b>Examples:</b><br/><br/>
(load-foreign-library "somelib.so") => NIL<br/><br/><b>See Also:</b> 
<a href="#call-foreign-function">call-foreign-function</a><hr/>
<a name="load-object"></a>
<i>Special Operator</i><b> load-object</b><br/><br/>
<b>Syntax:</b> (load-object str) => result<br/><br/>
<b>Arguments:</b> str: a form that evaluates to a string; result: an object<br/><br/>
<b>Description: load-object</b> loads the object serialized in the file named <i>str</i><br/><br/>
<b>Exceptions: </b>Throws an exception of type COMPILE-ERROR if no arguments are supplied. Throws an exception of type INVALID-ARGUMENT if the argument is not a string. An exception of type EXCEPTION is thrown if the file is not a valid file (created using save-object)<br/><br/>
<b>Examples:</b><br/><br/>
(load-object "object.lisp") => <an object><br/><br/><b>See Also:</b> 
<a href="#save-object">save-object</a><hr/>
<a name="macro"></a>
<i>Special Operator</i><b> macro</b><br/><br/>
<b>Syntax:</b> (macro params &rest body) => result<br/><br/>
<b>Arguments:</b> params: a list; body: the rest of the arguments converted into a list; result: a macro object<br/><br/>
<b>Description: macro</b> creates a macro object with params <i>params</i> and body <i>body</i><br/><br/>
<b>Exceptions: </b>Throws an exception of type COMPILE-ERROR if exactly two arguments are not supplied or if the first argument is not a list<br/><br/>
<b>Examples:</b><br/><br/>
(macro (x) `(car ,x)) => <macro><br/><br/><b>See Also:</b> 
<a href="#defmacro">defmacro</a><hr/>
<a name="macrop"></a>
<i>Special Operator</i><b> macrop</b><br/><br/>
<b>Syntax:</b> (macrop form) => result<br/><br/>
<b>Arguments:</b> form: an object; result: T or NIL<br/><br/>
<b>Description: macrop</b> returns T if <i>form</i> evaluates to a macro object and NIL otherwise<br/><br/>
<b>Exceptions: </b>Throws an exception of type COMPILE-ERROR if no arguments are supplied<br/><br/>
<b>Examples:</b><br/><br/>
(macrop defun) => T<br/><br/>(macrop 10) => NIL<br/><br/><b>See Also:</b> 
<hr/>
<a name="make-array"></a>
<i>Special Operator</i><b> make-array</b><br/><br/>
<b>Syntax:</b> (make-array size val) => result<br/><br/>
<b>Arguments:</b> size: an integer; val: an object; result: an array object<br/><br/>
<b>Description: make-array</b> creates an array of size <i>size</i>  with all the array elements initialized to <i>val</i><br/><br/>
<b>Exceptions: </b>Throws an exception of type COMPILE-ERROR if no arguments are supplied. Throws an exception of type INVALID-ARGUMENT if the first argument is not an integer<br/><br/>
<b>Examples:</b><br/><br/>
(make-array 5 1) => [1 1 1 1 1]<br/><br/>(make-array 3 nil) => [NIL NIL NIL]<br/><br/><b>See Also:</b> 
<a href="#make-string">make-string</a><hr/>
<a name="make-string"></a>
<i>Macro</i><b> make-string</b><br/><br/>
<b>Syntax:</b> (make-string size val) => result<br/><br/>
<b>Arguments:</b> size: an integer; val: a character; result: a string object<br/><br/>
<b>Description: make-string</b> creates a string of length <i>size</i>, with all the string positions initialized to <i>val</i><br/><br/>
<b>Exceptions: </b>Throws an exception of type COMPILE-ERROR if no arguments are supplied. Throws an exception of type INVALID-ARGUMENT if the first argument is not an integer<br/><br/>
<b>Examples:</b><br/><br/>
(make-string 5 #\a) => "aaaaa"<br/><br/><b>See Also:</b> 
<a href="#make-array">make-array</a><hr/>
<a name="map"></a>
<i>Macro</i><b> map</b><br/><br/>
<b>Syntax:</b> (map fn lst) => result<br/><br/>
<b>Arguments:</b> fn: a function object; lst: a list; result: a list<br/><br/>
<b>Description: map</b> applies the function <i>fn</i> to each element in <i>lst</i> and returns a newly-constructed list comprising the result of the function applications<br/><br/>
<b>Exceptions: </b>Throws an exception of type COMPILE-ERROR if the required number of arguments is not supplied. Throws an exception of type NOT-A-CONS if <i>lst</i> is not a list. An exception of type EXCEPTION is thrown if <i>fn</i> is not a function object<br/><br/>
<b>Examples:</b><br/><br/>
(map (lambda (x) (* 2 x)) '(1 2 3 4 5)) => (2 4 6 8 10)<br/><br/><b>See Also:</b> 
<a href="#mapcan">mapcan</a>, <a href="#mapcar">mapcar</a><hr/>
<a name="mapcan"></a>
<i>Macro</i><b> mapcan</b><br/><br/>
<b>Syntax:</b> (mapcan fn &rest lsts) => result<br/><br/>
<b>Arguments:</b> fn: a function object; lsts: the rest of the arguments converted into a list<br/><br/>
<b>Description: For</b> i ranging from zero to <i>min</i>, where <i>min</i> is the minimum of the lengths of the lists <i>lsts</i>, mapcan takes the ith element of each of the lists in <i>lsts</i> and applies <i>fn</i> to the list of arguments thus formed. It collects the results of these function applications in a list and returns the flattened list<br/><br/>
<b>Exceptions: </b>Throws an exception of type COMPILE-ERROR if the required number of arguments is not supplied. Throws an exception of type NOT-A-CONS if <i>lst</i> is not a list. An exception of type INVALID-ARGUMENT is thrown if <i>fn</i> is not a function object<br/><br/>
<b>Examples:</b><br/><br/>
(mapcan (lambda (x y) (list x y)) '(1 2) '(3 4)) => (1 3 2 4)<br/><br/><b>See Also:</b> 
<a href="#map">map</a>, <a href="#mapcar">mapcar</a><hr/>
<a name="mapcar"></a>
<i>Function</i><b> mapcar</b><br/><br/>
<b>Syntax:</b> (mapcar fn &rest lsts) => result<br/><br/>
<b>Arguments:</b> fn: a function object; lsts: the rest of the arguments converted into a list<br/><br/>
<b>Description: For</b> i ranging from zero to <i>min</i>, where <i>min</i> is the minimum of the lengths of the lists lsts, mapcan takes the ith element of each of the lists in <i>lsts</i> and applies <i>fn</i> to the list of arguments thus formed. It collects the results of these function applications in a list and returns this list.<br/><br/>
<b>Exceptions: </b>Throws an exception of type COMPILE-ERROR if the required number of arguments is not supplied. Throws an exception of type NOT-A-CONS if <i>lst</i> is not a list. An exception of type INVALID-ARGUMENT is thrown if <i>fn</i> is not a function object<br/><br/>
<b>Examples:</b><br/><br/>
(mapcar (lambda (x y) (list x y)) '(1 2) '(3 4)) => ((1 3) (2 4))<br/><br/><b>See Also:</b> 
<a href="#map">map</a>, <a href="#mapcan">mapcan</a><hr/>
<a name="max"></a>
<i>Function</i><b> max</b><br/><br/>
<b>Syntax:</b> (max lst) => result<br/><br/>
<b>Arguments:</b> lst: a list; result: an object<br/><br/>
<b>Description: max</b> returns the largest element in <i>lst</i><br/><br/>
<b>Exceptions: </b>Throws an exception of type COMPILE-ERROR if no arguments are supplied. An exception of type NOT-A-CONS is thrown if <i>lst</i> is not a list<br/><br/>
<b>Examples:</b><br/><br/>
(max '(2 3 7 8 10 9)) => 10<br/><br/><b>See Also:</b> 
<a href="#min">min</a><hr/>
<a name="min"></a>
<i>Function</i><b> min</b><br/><br/>
<b>Syntax:</b> (min lst) => result<br/><br/>
<b>Arguments:</b> lst: a list; result: an object<br/><br/>
<b>Description: min</b> returns the smallest element in <i>lst</i><br/><br/>
<b>Exceptions: </b>Throws an exception of type COMPILE-ERROR if no arguments are supplied. An exception of type NOT-A-CONS is thrown if <i>lst</i> is not a list<br/><br/>
<b>Examples:</b><br/><br/>
(min '(2 3 7 8 10 9)) => 2<br/><br/><b>See Also:</b> 
<a href="#max">max</a><hr/>
<a name="multiple-value-bind"></a>
<i>Macro</i><b> multiple-value-bind</b><br/><br/>
<b>Syntax:</b> (multiple-value-bind vars var-form &rest body) => result<br/><br/>
<b>Arguments:</b> vars: a list of symbols; var-form: a list; body: the rest of the arguments converted into a list; result: an object<br/><br/>
<b>Description: multiple-value-bind</b> binds <i>vars</i> to the values specified in <i>var-form</i> and evaluates the expressions in <i>body</i><br/><br/>
<b>Exceptions: </b>Throws an exception of type COMPILE-ERROR if the required number of arguments is not supplied or if the first parameter is not a list of symbols. An exception of type INVALID-ARGUMENT is thrown if the second parameter is not a list. An exception of type EXCEPTION is thrown if there is a mismatch/inconsistency in the number/binding of variables among <i>vars</i>, <i>var-form</i> and <i>body</i>.<br/><br/>
<b>Examples:</b><br/><br/>
(multiple-value-bind (x y) '(3 4) (+ x y)) => 7<br/><br/><b>See Also:</b> 
<a href="#values">values</a><hr/>
<a name="nconc"></a>
<i>Macro</i><b> nconc</b><br/><br/>
<b>Syntax:</b> (nconc sym &rest lsts) => result<br/><br/>
<b>Arguments:</b> sym: a symbol; lsts: the rest of the arguments (which are themselves lists) converted into a list; result: a list<br/><br/>
<b>Description: nconc</b> appends <i>lsts</i> to the list object bound to the symbol <i>sym</i><br/><br/>
<b>Exceptions: </b>Throws an exception of type COMPILE-ERROR if no arguments are supplied. An exception of type EXCEPTION is thrown if <i>sym</i> is undefined. An exception of type INVALID-ARGUMENT is thrown if <i>sym</i> is not bound to a list object or if any of the elements of <i>lsts</i> is not a list<br/><br/>
<b>Examples:</b><br/><br/>
(define x '(1 2 3)) => (1 2 3)<br/><br/>x => (1 2 3)<br/><br/>(nconc x '(4 5 6) '(7 8 9)) => (1 2 3 4 5 6 7 8 9)<br/><br/>x => (1 2 3 4 5 6 7 8 9)<br/><br/><b>See Also:</b> 
<a href="#append">append</a>, <a href="#concat">concat</a><hr/>
<a name="neq"></a>
<i>Macro</i><b> neq</b><br/><br/>
<b>Syntax:</b> (neq form1 form2) => result<br/><br/>
<b>Arguments:</b> form1, form2: forms; result: T or NIL<br/><br/>
<b>Description: neq</b> returns T if <i>form1</i> and <i>form2</i> are not structurally equivalent and NIL otherwise<br/><br/>
<b>Exceptions: </b>Throws en exception of type COMPILE-ERROR if two arguments are not supplied<br/><br/>
<b>Examples:</b><br/><br/>
(neq 1 1) => NIL<br/><br/>(neq '(1 2) '(1 2)) => NIL<br/><br/>(define x "abc") => "abc"<br/><br/>(neq x "abc") => NIL<br/><br/>(neq 1 'a) => T<br/><br/><b>See Also:</b> 
<a href="#eq">eq</a><hr/>
<a name="newline"></a>
<i>Special Operator</i><b> newline</b><br/><br/>
<b>Syntax:</b> (newline fd) => NIL<br/><br/>
<b>Arguments:</b> fd: an integer or NIL<br/><br/>
<b>Description: newline</b> prints a newline to the file specified by the file descriptor <i>fd</i> if <i>fd</i> is not NIL, and to the Transcript window or the shell if <i>fd</i> is NIL<br/><br/>
<b>Exceptions: </b>Throws an exception of type COMPILE-ERROR if no arguments are supplied. An exception of type INVALID-ARGUMENT is thrown if <i>fd</i> is not a valid file descriptor<br/><br/>
<b>Examples:</b><br/><br/>
<b>See Also:</b> 
<a href="#println">println</a><hr/>
<a name="not"></a>
<i>Special Operator</i><b> not</b><br/><br/>
<b>Syntax:</b> (not form) => result<br/><br/>
<b>Arguments:</b> form: a form; result: T or NIL<br/><br/>
<b>Description: not</b> returns T if <i>form</i> evaluates to NIL and NIL otherwise<br/><br/>
<b>Exceptions: </b>Throws an exception of type COMPILE-ERROR if no arguments are supplied<br/><br/>
<b>Examples:</b><br/><br/>
(not (eq 1 1)) => NIL<br/><br/>(not (eq 1 #\a)) => T<br/><br/><b>See Also:</b> 
<a href="#null">null</a><hr/>
<a name="nth"></a>
<i>Function</i><b> nth</b><br/><br/>
<b>Syntax:</b> (nth lst n) => result<br/><br/>
<b>Arguments:</b> lst: a list; n: an integer; result: an object<br/><br/>
<b>Description: nth</b> returns the nth element in <i>lst</i>. Note that list indices start from zero<br/><br/>
<b>Exceptions: </b>Throws an exception of type COMPILE-ERROR if the required number of arguments is not supplied. An exception of type EXCEPTION is thrown if <i>lst</i> is not a list. Throws an exception of type INVALID-ARGUMENT if <i>n</i> is not an integer<br/><br/>
<b>Examples:</b><br/><br/>
(nth 3 '(2 3 7 8 10 9)) => 8<br/><br/><b>See Also:</b> 
<a href="#first">first</a>, <a href="#second">second</a>, <a href="#third">third</a>, <a href="#fourth">fourth</a>, <a href="#fifth">fifth</a><hr/>
<a name="null"></a>
<i>Function</i><b> null</b><br/><br/>
<b>Syntax:</b> (null form) => result<br/><br/>
<b>Arguments:</b> form: an object; result: T or NIL<br/><br/>
<b>Description: null</b> returns T if <i>form</i> evaluates to NIL and NIL otherwise<br/><br/>
<b>Exceptions: </b>Throws an exception of type COMPILE-ERROR if no arguments are supplied.<br/><br/>
<b>Examples:</b><br/><br/>
(null 1) => NIL<br/><br/>(null '()) => T<br/><br/><b>See Also:</b> 
<a href="#not">not</a><hr/>
<a name="numberp"></a>
<i>Function</i><b> numberp</b><br/><br/>
<b>Syntax:</b> (numberp form) => result<br/><br/>
<b>Arguments:</b> form: an object; result: T or NIL<br/><br/>
<b>Description: numberp</b> returns T if <i>form</i> evaluates to an integer or a float and NIL otherwise<br/><br/>
<b>Exceptions: </b>Throws an exception of type COMPILE-ERROR if no arguments are supplied.<br/><br/>
<b>Examples:</b><br/><br/>
(numberp 1) => T<br/><br/>(numberp 3.14) => T<br/><br/>(numberp 'a) => NIL<br/><br/><b>See Also:</b> 
<a href="#integerp">integerp</a>, <a href="#floatp">floatp</a><hr/>
<a name="or"></a>
<i>Macro</i><b> or</b><br/><br/>
<b>Syntax:</b> (or form*) => result<br/><br/>
<b>Arguments:</b> form: an object; result: T or NIL<br/><br/>
<b>Description: or</b> performs a logical disjunction of its operands. Returns T if any of the operands evaluates to non-NIL and NIL otherwise. Returns T if no arguments are passed<br/><br/>
<b>Exceptions: </b>None<br/><br/>
<b>Examples:</b><br/><br/>
(or (eq 1 1) (eq 2 3)) => T<br/><br/>(or (eq 2 3) (eq 1 2)) => NIL<br/><br/><b>See Also:</b> 
<a href="#and">and</a><hr/>
<a name="pair"></a>
<i>Function</i><b> pair</b><br/><br/>
<b>Syntax:</b> (pair lst1 lst2) => result<br/><br/>
<b>Arguments:</b> lst1, lst2: lists; result: a list<br/><br/>
<b>Description: pair</b> creates pairs by forming a list from objects in <i>lst1</i> and <i>lst2</i> that share the same ordinal position. If the lengths of <i>lst1</i> and <i>lst2</i> are not the same, the lists are created by substituting with NILs<br/><br/>
<b>Exceptions: </b>Throws an exception of type COMPILE-ERROR if the required number of parameters is not supplied. An exception of type NOT-A-CONS is thrown if either of the arguments is neither a list nor NIL<br/><br/>
<b>Examples:</b><br/><br/>
(pair '(1 2 3) '(4 5 6 7)) => ((1 4) (2 5) (3 6) (NIL 7))<br/><br/><b>See Also:</b> 
<a href="#cons-pair">cons-pair</a><hr/>
<a name="print"></a>
<i>Special Operator</i><b> print</b><br/><br/>
<b>Syntax:</b> (print obj) => NIL<br/><br/>
<b>Arguments:</b> obj: an object<br/><br/>
<b>Description: print</b> prints the object <i>obj</i> to the shell if pLisp is invoked with <i>-c</i> and to the Transcript if otherwise<br/><br/>
<b>Exceptions: </b>Throws an exception of type COMPILE-ERROR if no arguments are supplied<br/><br/>
<b>Examples:</b><br/><br/>
(print "Hello world") =><br/><br/>"Hello world"<br/><br/>"Hello world"<br/><br/>(print (make-array 5 nil)) =><br/><br/>[NIL NIL NIL NIL NIL]<br/><br/>[NIL NIL NIL NIL NIL]<br/><br/><b>See Also:</b> 
<a href="#print-string">print-string</a><hr/>
<a name="print-string"></a>
<i>Special Operator</i><b> print-string</b><br/><br/>
<b>Syntax:</b> (print-string str) => NIL<br/><br/>
<b>Arguments:</b> str: a form that evaluates to a string object<br/><br/>
<b>Description: print-string</b> prints the string object <i>str</i> to the shell if pLisp is invoked with <i>-c</i> and to the Transcript if otherwise<br/><br/>
<b>Exceptions: </b>Throws an exception of type COMPILE-ERROR if no arguments are supplied, and an exception of type INVALID-ARGUMENT if <i>str</i> is not a string<br/><br/>
<b>Examples:</b><br/><br/>
(print-string "Hello world") =><br/><br/>"Hello world"NIL<br/><br/>(define x "abc") => "abc"<br/><br/>(print-string x) =><br/><br/>"abc"NIL<br/><br/><b>See Also:</b> 
<a href="#print">print</a><hr/>
<a name="println"></a>
<i>Macro</i><b> println</b><br/><br/>
<b>Syntax:</b> (println) => NIL<br/><br/>
<b>Arguments:</b> None<br/><br/>
<b>Description: println</b> prints a newline to the shell<br/><br/>
<b>Exceptions: </b>None<br/><br/>
<b>Examples:</b><br/><br/>
<b>See Also:</b> 
<a href="#newline">newline</a><hr/>
<a name="profile"></a>
<i>Special Operator</i><b> profile</b><br/><br/>
<b>Syntax:</b> (profile exp) => NIL<br/><br/>
<b>Arguments:</b> exp: a quoted form<br/><br/>
<b>Description: profile</b> evaluates <i>exp</i> and displays the resource usage information for the evaluation<br/><br/>
<b>Exceptions: </b>Propagates exceptions thrown (if any) by the evaluation of the form<br/><br/>
<b>Examples:</b><br/><br/>
(profile '(+ 1 1)) =><br/><br/>Expression took 0.017554 seconds (elapsed), 0.013966 seconds (CPU), 2696 words allocated<br/><br/>2<br/><br/><b>See Also:</b> 
<a href="#time">time</a><hr/>
<a name="progn"></a>
<i>Macro</i><b> progn</b><br/><br/>
<b>Syntax:</b> (progn form*) => result<br/><br/>
<b>Arguments:</b> form: a form; result: an object<br/><br/>
<b>Description: progn</b> evaluates each of the forms supplied to it as arguments and returns the result of the evaluation of the last form<br/><br/>
<b>Exceptions: </b>Propagates exceptions thrown (if any) by the evaluation of any of the forms<br/><br/>
<b>Examples:</b><br/><br/>
(progn (print "hello") (+ 1 1)) =><br/><br/>"hello"<br/><br/>2<br/><br/><b>See Also:</b> 
<hr/>
<a name="range"></a>
<i>Function</i><b> range</b><br/><br/>
<b>Syntax:</b> (range start end inc) => result<br/><br/>
<b>Arguments:</b> start, end, inc: integers or floats; result: a list<br/><br/>
<b>Description: range</b> creates a list with <i>start</i> as the first element and <i>end</i> as the last element, with the middle elements obtained by successively incrementing <i>start</i> with <i>inc</i><br/><br/>
<b>Exceptions: </b>Throws an exception of type COMPILE-ERROR if the required number of arguments is not supplied. An exception of type INVALID-EXCEPTION is thrown if any of the arguments is neither an integer nor a float<br/><br/>
<b>Examples:</b><br/><br/>
(range 1 10 1) => (1 2 3 4 5 6 7 8 9 10)<br/><br/><b>See Also:</b> 
<hr/>
<a name="read"></a>
<i>Function</i><b> read</b><br/><br/>
<b>Syntax:</b> (read) => result<br/><br/>
<b>Arguments:</b> result: an integer, float or string object<br/><br/>
<b>Description: read</b> reads a value from the standard input and returns an integer, float or string object after suitably converting the value<br/><br/>
<b>Exceptions: </b>Throws an exception of type COMPILE-ERROR if any arguments are supplied, and an exception of type EXCEPTION if the read was unsuccessful<br/><br/>
<b>Examples:</b><br/><br/>
<b>See Also:</b> 
<a href="#read-character">read-character</a>, <a href="#read-float">read-float</a>, <a href="#read-integer">read-integer</a>, <a href="#read-string">read-string</a><hr/>
<a name="read-character"></a>
<i>Function</i><b> read-character</b><br/><br/>
<b>Syntax:</b> (read-character) => result<br/><br/>
<b>Arguments:</b> result: a character object<br/><br/>
<b>Description: read-character</b> reads a character from the standard input<br/><br/>
<b>Exceptions: </b>Throws an exception of type COMPILE-ERROR if any arguments are supplied, and an exception of type NOT-A-STRING if an integer or a float is entered<br/><br/>
<b>Examples:</b><br/><br/>
<b>See Also:</b> 
<a href="#read">read</a>, <a href="#read-float">read-float</a>, <a href="#read-integer">read-integer</a>, <a href="#read-string">read-string</a><hr/>
<a name="read-float"></a>
<i>Function</i><b> read-float</b><br/><br/>
<b>Syntax:</b> (read-float) => result<br/><br/>
<b>Arguments:</b> result: a float object<br/><br/>
<b>Description: read-float</b> reads a float from the standard input<br/><br/>
<b>Exceptions: </b>Throws an exception of type COMPILE-ERROR if any arguments are supplied, and an exception of type NOT-A-FLOAT if a character or string is entered<br/><br/>
<b>Examples:</b><br/><br/>
<b>See Also:</b> 
<a href="#read">read</a>, <a href="#read-character">read-character</a>, <a href="#read-integer">read-integer</a>, <a href="#read-string">read-string</a><hr/>
<a name="read-integer"></a>
<i>Function</i><b> read-integer</b><br/><br/>
<b>Syntax:</b> (read-integer) => result<br/><br/>
<b>Arguments:</b> result: an integer object<br/><br/>
<b>Description: read-integer</b> reads an integer from the standard input<br/><br/>
<b>Exceptions: </b>Throws an exception of type COMPILE-ERROR if any arguments are supplied, and an exception of type NOT-AN-INTEGER if a character or string is entered<br/><br/>
<b>Examples:</b><br/><br/>
<b>See Also:</b> 
<a href="#read">read</a>, <a href="#read-character">read-character</a>, <a href="#read-float">read-float</a>, <a href="#read-string">read-string</a><hr/>
<a name="read-string"></a>
<i>Function</i><b> read-string</b><br/><br/>
<b>Syntax:</b> (read-string) => result<br/><br/>
<b>Arguments:</b> result: a string object<br/><br/>
<b>Description: read-string</b> reads a string from the standard input<br/><br/>
<b>Exceptions: </b>Throws an exception of type COMPILE-ERROR if any arguments are supplied, and an exception of type NOT-A-STRING if an integer or a float is entered<br/><br/>
<b>Examples:</b><br/><br/>
<b>See Also:</b> 
<a href="#read">read</a>, <a href="#read-character">read-character</a>, <a href="#read-float">read-float</a>, <a href="#read-integer">read-integer</a><hr/>
<a name="remove"></a>
<i>Function</i><b> remove</b><br/><br/>
<b>Syntax:</b> (remove e lst n) => result<br/><br/>
<b>Arguments:</b> e: an object; lst: a list; result: a list<br/><br/>
<b>Description: remove</b> removes the first <i>n</i> occurrences of <i>e</i> from <i>lst</i><br/><br/>
<b>Exceptions: </b>Throws an exception of type COMPILE-ERROR if the required number of arguments is not supplied. An exception of type NOT-A-CONS is thrown if <i>lst</i> is not a list<br/><br/>
<b>Examples:</b><br/><br/>
(remove 1 '(1 1 2 1 3 4) 2) => (2 1 3 4)<br/><br/><b>See Also:</b> 
<a href="#remove-duplicates">remove-duplicates</a>, <a href="#remove-if">remove-if</a>, <a href="#remove-if-not">remove-if-not</a>, <a href="#remove-last">remove-last</a><hr/>
<a name="remove-duplicates"></a>
<i>Macro</i><b> remove-duplicates</b><br/><br/>
<b>Syntax:</b> (remove-duplicates lst test) => result<br/><br/>
<b>Arguments:</b> lst: a list; test: a function object; result: a list<br/><br/>
<b>Description: remove-duplicates</b> removes duplicates from <i>lst</i>, using <i>test</i> to test for equality<br/><br/>
<b>Exceptions: </b>Throws an exception of type COMPILE-ERROR if the required number of arguments is not supplied. An exception of type NOT-A-CONS is thrown if <i>lst</i> is not a list. An exception of type EXCEPTION is thrown if <i>test</i> is not a function<br/><br/>
<b>Examples:</b><br/><br/>
(remove-duplicates '(1 1 2 1 3 4) (lambda (x y) (eq x y))) => (1 2 3 4)<br/><br/><b>See Also:</b> 
<a href="#remove">remove</a>, <a href="#remove-if">remove-if</a>, <a href="#remove-if-not">remove-if-not</a>, <a href="#remove-last">remove-last</a><hr/>
<a name="remove-if"></a>
<i>Function</i><b> remove-if</b><br/><br/>
<b>Syntax:</b> (remove-if pred lst) => result<br/><br/>
<b>Arguments:</b> pred: a function object; lst: a list; result: a list<br/><br/>
<b>Description: remove-if</b> removes those elements in <i>lst</i> for which <i>pred</i> returns a non-NIL value<br/><br/>
<b>Exceptions: </b>Throws an exception of type COMPILE-ERROR if the required number of arguments is not supplied. An exception of type NOT-A-CONS is thrown if <i>lst</i> is not a list. An exception of type EXCEPTION is thrown if <i>pred</i> is not a function<br/><br/>
<b>Examples:</b><br/><br/>
(remove-if (lambda (x) (>= x 3)) '(1 1 2 1 3 4)) => (1 1 2 1)<br/><br/><b>See Also:</b> 
<a href="#remove">remove</a>, <a href="#remove-duplicates">remove-duplicates</a>, <a href="#remove-if-not">remove-if-not</a>, <a href="#remove-last">remove-last</a><hr/>
<a name="remove-if-not"></a>
<i>Macro</i><b> remove-if-not</b><br/><br/>
<b>Syntax:</b> (remove-if-not pred lst) => result<br/><br/>
<b>Arguments:</b> pred: a function; lst: a list; result: a list<br/><br/>
<b>Description: remove-if-not</b> removes those elements in <i>lst</i> for which <i>pred</i> returns NIL<br/><br/>
<b>Exceptions: </b>Throws an exception of type COMPILE-ERROR if the required number of arguments is not supplied. An exception of type NOT-A-CONS is thrown if <i>lst</i> is not a list. An exception of type EXCEPTION is thrown if <i>pred</i> is not a function<br/><br/>
<b>Examples:</b><br/><br/>
(remove-if-not (lambda (x) (>= x 3)) '(1 1 2 1 3 4)) => (3 4)<br/><br/><b>See Also:</b> 
<a href="#remove">remove</a>, <a href="#remove-duplicates">remove-duplicates</a>, <a href="#remove-if">remove-if</a>, <a href="#remove-last">remove-last</a><hr/>
<a name="remove-last"></a>
<i>Function</i><b> remove-last</b><br/><br/>
<b>Syntax:</b> (remove-last lst) => result<br/><br/>
<b>Arguments:</b> lst: a list; result: a list<br/><br/>
<b>Description: remove-last</b> removes the last element in <i>lst</i><br/><br/>
<b>Exceptions: </b>Throws an exception of type COMPILE-ERROR if no arguments are supplied. An exception of type EXCEPTION is thrown if <i>lst</i> is not a list<br/><br/>
<b>Examples:</b><br/><br/>
(remove-last '(1 1 2 1 3 4)) => (1 1 2 1 3)<br/><br/><b>See Also:</b> 
<a href="#remove">remove</a>, <a href="#remove-duplicates">remove-duplicates</a>, <a href="#remove-if">remove-if</a>, <a href="#remove-if-not">remove-if-not</a><hr/>
<a name="rest"></a>
<i>Macro</i><b> rest</b><br/><br/>
<b>Syntax:</b> (rest lst) => result<br/><br/>
<b>Arguments:</b> lst: a form that evaluates to a list; result: an object<br/><br/>
<b>Description: rest</b> retuns the list comprising all the elements of <i>lst</i> except the first one<br/><br/>
<b>Exceptions: </b>Throws an exception of type COMPILE-ERROR if no arguments are supplied, and an exception of type NOT-A-CONS if lst is not a list<br/><br/>
<b>Examples:</b><br/><br/>
(rest '(1 2 3 4)) => (2 3 4)<br/><br/><b>See Also:</b> 
<a href="#cdr">cdr</a><hr/>
<a name="resume"></a>
<i>Special Operator</i><b> resume</b><br/><br/>
<b>Syntax:</b> (resume) => NIL<br/><br/>
<b>Arguments:</b> None<br/><br/>
<b>Description: resume</b> resumes the evaluation of the expression after a BREAK<br/><br/>
<b>Exceptions: </b>None; an error is raised if abort is invoked when not in debug mode (entered via a <i>break</i>)<br/><br/>
<b>Examples:</b><br/><br/>
<b>See Also:</b> 
<a href="#abort">abort</a>, <a href="#break">break</a><hr/>
<a name="return-from"></a>
<i>Special Operator</i><b> return-from</b><br/><br/>
<b>Syntax:</b> (return-from fn ret) => result<br/><br/>
<b>Arguments:</b> fn: a function or a macro object; ret: an object; result: an object<br/><br/>
<b>Description: return-from</b> returns control from the execution of <i>fn</i> to its calling frame with <i>fn</i> returning the value <i>ret</i><br/><br/>
<b>Exceptions: </b>Throws an exception of type EXCEPTION if the required number of arguments is not supplied, if the first parameter is not a function object or if it is invoked in an invalid context (e.g. from the REPL or the workspace)<br/><br/>
<b>Examples:</b><br/><br/>
<b>See Also:</b> 
<hr/>
<a name="reverse"></a>
<i>Function</i><b> reverse</b><br/><br/>
<b>Syntax:</b> (reverse lst) => result<br/><br/>
<b>Arguments:</b> lst: a list; result: a list<br/><br/>
<b>Description: reverse</b> creates a new list that contains the contents of <i>lst</i> in reverse order<br/><br/>
<b>Exceptions: </b>Throws an exception of type COMPILE-ERROR if no arguments are supplied, and an exception of type NOT-A-CONS if <i>lst</i> is not a list<br/><br/>
<b>Examples:</b><br/><br/>
(reverse '(1 1 2 1 3 4)) => (4 3 1 2 1 1)<br/><br/><b>See Also:</b> 
<hr/>
<a name="save-object"></a>
<i>Special Operator</i><b> save-object</b><br/><br/>
<b>Syntax:</b> (save-object obj str) => NIL<br/><br/>
<b>Arguments:</b> obj: an object; str: a form that evaluates to a string<br/><br/>
<b>Description: save-object</b> serializes the object <i>obj</i> to the file named <i>str</i>. All objects referred to by <i>obj</i> are included in this serialization<br/><br/>
<b>Exceptions: </b>Throws an exception of type COMPILE-ERROR if the required number of arguments is not supplied. Throws an exception of type INVALID-ARGUMENT if the second argument is not a string. An exception of type EXCEPTION is thrown if the file cannot be created<br/><br/>
<b>Examples:</b><br/><br/>
(save-object some-obj "object.lisp") => NIL<br/><br/><b>See Also:</b> 
<a href="#load-object">load-object</a><hr/>
<a name="second"></a>
<i>Macro</i><b> second</b><br/><br/>
<b>Syntax:</b> (second lst) => result<br/><br/>
<b>Arguments:</b> lst: a list; result: an object<br/><br/>
<b>Description: second</b> returns the second element of a list<br/><br/>
<b>Exceptions: </b>Throws an exception of type COMPILE-ERROR if no arguments are supplied, and an exception of type NOT-A-CONS if <i>lst</i> is not a list<br/><br/>
<b>Examples:</b><br/><br/>
(second '(1 2 3)) => 2<br/><br/>(second ()) => NIL<br/><br/><b>See Also:</b> 
<a href="#caar">caar</a>, <a href="#cadar">cadar</a>, <a href="#cadddr">cadddr</a>, <a href="#caddr">caddr</a>, <a href="#cadr">cadr</a>, <a href="#car">car</a>, <a href="#cdar">cdar</a>, <a href="#cddr">cddr</a>, <a href="#cdr">cdr</a>, <a href="#first">first</a>, <a href="#third">third</a>, <a href="#fourth">fourth</a>, <a href="#fifth">fifth</a><hr/>
<a name="select"></a>
<i>Function</i><b> select</b><br/><br/>
<b>Syntax:</b> (select pred lst) => result<br/><br/>
<b>Arguments:</b> pred: a function; lst: a list; result: a list<br/><br/>
<b>Description: select</b> builds a new list containing the elements in <i>lst</i> for which <i>pred</i> evaluates to a non-NIL value<br/><br/>
<b>Exceptions: </b>Throws an exception of type COMPILE-ERROR if no arguments are passed. An exception of type NOT-A-CONS is thrown if <i>lst</i> is not a list. Throws an exception of type EXCEPTION if <i>pred</i> is not a function object<br/><br/>
<b>Examples:</b><br/><br/>
(select (lambda (x) (numberp x)) '(1 2 #\a "abc" 'x)) => (1 2)<br/><br/><b>See Also:</b> 
<a href="#find">find</a>, <a href="#find-if">find-if</a><hr/>
<a name="setcar"></a>
<i>Special Operator</i><b> setcar</b><br/><br/>
<b>Syntax:</b> (setcar lst obj) => obj<br/><br/>
<b>Arguments:</b> lst: a list; obj: an object<br/><br/>
<b>Description: setcar</b> updates the CAR of <i>lst</i> to <i>obj</i><br/><br/>
<b>Exceptions: </b>Throws an exception of type COMPILE-ERROR if exactly two arguments are not supplied and an exception of type NOT-A-CONS if the first argument is not a list<br/><br/>
<b>Examples:</b><br/><br/>
(define x '(1 2)) => (1 2)<br/><br/>x => (1 2)<br/><br/>(setcar x 100) => 100<br/><br/>x => (100 2)<br/><br/><b>See Also:</b> 
<a href="#setcdr">setcdr</a><hr/>
<a name="setcdr"></a>
<i>Special Operator</i><b> setcdr</b><br/><br/>
<b>Syntax:</b> (setcdr lst obj) => obj<br/><br/>
<b>Arguments:</b> lst: a list; obj: an object<br/><br/>
<b>Description: setcar</b> updates the CDR of <i>lst</i> to <i>obj</i><br/><br/>
<b>Exceptions: </b>Throws an exception of type COMPILE-ERROR if exactly two arguments are not supplied and an exception of type NOT-A-CONS if the first argument is not a list<br/><br/>
<b>Examples:</b><br/><br/>
(define x '(1 2)) => (1 2)<br/><br/>x => (1 2)<br/><br/>(setcdr x 100) => 100<br/><br/>x => (1 . 100)<br/><br/><b>See Also:</b> 
<a href="#setcar">setcar</a><hr/>
<a name="set"></a>
<i>Special Operator</i><b> set</b><br/><br/>
<b>Syntax:</b> (set var obj) => obj<br/><br/>
<b>Arguments:</b> var: a symbol; obj: an object<br/><br/>
<b>Description: set</b> binds <i>var</i> to <i>obj</i><br/><br/>
<b>Exceptions: </b>Throws an exception of type INVALID-ARGUMENT if the required number of arguments are not supplied or if the first argument is not a symbol. Throws exception EXCEPTION if <i>var</i> has not been defined<br/><br/>
<b>Examples:</b><br/><br/>
(define x) => NIL<br/><br/>(set x 100) => 100<br/><br/>x => 100<br/><br/><b>See Also:</b> 
<a href="#setq">setq</a><hr/>
<a name="setq"></a>
<i>Macro</i><b> setq</b><br/><br/>
<b>Syntax:</b> (setq var obj) => obj<br/><br/>
<b>Arguments:</b> var: a symbol; obj: an object<br/><br/>
<b>Description: setq</b> binds <i>var</i> to <i>obj</i>; it is identical to <i>set</i> and is defined to provide limited compatibility to Common Lisp<br/><br/>
<b>Exceptions: </b>Throws an exception of type INVALID-ARGUMENT if the required number of arguments are not supplied or if the first argument is not a symbol. Throws exception EXCEPTION if <i>var</i> has not been defined<br/><br/>
<b>Examples:</b><br/><br/>
(define x) => NIL<br/><br/>(setq x 100) => 100<br/><br/>x => 100<br/><br/><b>See Also:</b> 
<a href="#set">set</a><hr/>
<a name="string"></a>
<i>Special Operator</i><b> string</b><br/><br/>
<b>Syntax:</b> (string str) => str<br/><br/>
<b>Arguments:</b> str: a string literal<br/><br/>
<b>Description: string</b> creates a string object from <i>str</i><br/><br/>
<b>Exceptions: </b>Throws an exception of type COMPILE-ERROR if no arguments are supplied. An exception of type INVALID-ARGUMENT is thrown if the argument is not a string literal<br/><br/>
<b>Examples:</b><br/><br/>
(define x) => NIL<br/><br/>(set x (string "abc")) => X<br/><br/>x => "abc"<br/><br/><b>See Also:</b> 
<hr/>
<a name="string-get"></a>
<i>Macro</i><b> string-get</b><br/><br/>
<b>Syntax:</b> (string-get str pos) => result<br/><br/>
<b>Arguments:</b> str: a form that evaluates to a string; pos: an integer; result: a character<br/><br/>
<b>Description: string-get</b> returns the character at position <i>pos</i> of <i>str</i>. Note that string indices start at zero<br/><br/>
<b>Exceptions: </b>Throws an exception of type COMPILE-ERROR if no arguments are supplied. Throws an exception of type INDEX-OUT-OF-BOUNDS if <i>pos</i> is not greater than or equal to zero or less than the size of <i>str</i>. An exception of type INVALID-ARGUMENT is thrown if <i>str</i> is not a string object or a string literal<br/><br/>
<b>Examples:</b><br/><br/>
(define x "abc") => "abc"<br/><br/>(string-get x 0) => #\a<br/><br/>(string-get x 2) => #\c<br/><br/><b>See Also:</b> 
<a href="#array-get">array-get</a>, <a href="#array-set">array-set</a>, <a href="#string-set">string-set</a><hr/>
<a name="string-set"></a>
<i>Macro</i><b> string-set</b><br/><br/>
<b>Syntax:</b> (string-set str pos val) => val<br/><br/>
<b>Arguments:</b> str: a form that evaluates to a string; pos: an integer; val: a character<br/><br/>
<b>Description: string-set</b> sets the character at position <i>pos</i> of <i>str</i> to <i>val</i>. Note that string indices start at zero<br/><br/>
<b>Exceptions: </b>Throws an exception of type COMPILE-ERROR if no arguments are supplied. Throws an exception of type INDEX-OUT-OF-BOUNDS if <i>pos</i> is not greater than or equal to zero or less than the size of <i>str</i>. An exception of type INVALID-ARGUMENT is thrown if <i>str</i> is not a string object or a string literal<br/><br/>
<b>Examples:</b><br/><br/>
(define x (string "abc")) => "abc"<br/><br/>(string-set x 0 #\d) => #\d<br/><br/>x => "dbc"<br/><br/><b>See Also:</b> 
<a href="#array-get">array-get</a>, <a href="#array-set">array-set</a>, <a href="#string-get">string-get</a><hr/>
<a name="stringp"></a>
<i>Special Operator</i><b> stringp</b><br/><br/>
<b>Syntax:</b> (stringp form) => result<br/><br/>
<b>Arguments:</b> form: an object; result: T or NIL<br/><br/>
<b>Description: stringp</b> returns T if <i>form</i> evaluates to a string object or a string literal and NIL otherwise<br/><br/>
<b>Exceptions: </b>Throws an exception of type COMPILE-ERROR if no arguments are supplied<br/><br/>
<b>Examples:</b><br/><br/>
(stringp "abc") => T<br/><br/>(stringp #\a) => NIL<br/><br/><b>See Also:</b> 
<hr/>
<a name="sub-array"></a>
<i>Special Operator</i><b> sub-array</b><br/><br/>
<b>Syntax:</b> (sub-array arr start len) => result<br/><br/>
<b>Arguments:</b> arr: a form that evaluates to an array; start, end: integers; result: an array<br/><br/>
<b>Description: sub-array</b> creates a new array comprising the elements starting from position <i>start</i> in <i>arr</i> till the position (start + len -1)<br/><br/>
<b>Exceptions: </b>Throws an exception of type COMPILE-ERROR if the required number of  arguments is not supplied. An exception of type INVALID-ARGUMENT is thrown if the first argument is not an array or if the second and third arguments are not non-negative integers. Throws an exception of type INDEX-OUT-OF-BOUNDS if <i>start</i> and <i>len</i> specify a range outside the array size<br/><br/>
<b>Examples:</b><br/><br/>
(define x (make-array 5 nil)) => [NIL NIL NIL NIL NIL]<br/><br/>(dolist (i '(0 1 2 3 4)) (array-set x i (+ i 1))) => NIL<br/><br/>x => [1 2 3 4 5]<br/><br/>(sub-array x 0 3) => [1 2 3]<br/><br/><b>See Also:</b> 
<a href="#substring">substring</a>, <a href="#sub-list">sub-list</a><hr/>
<a name="sub-list"></a>
<i>Function</i><b> sub-list</b><br/><br/>
<b>Syntax:</b> (sub-list lst start len) => result<br/><br/>
<b>Arguments:</b> lst: a form that evaluates to a list; start, end: integers; result: a list<br/><br/>
<b>Description: sub-list</b> creates a new list comprising the elements starting from position <i>start</i> in <i>lst</i> till the position (start + len -1)<br/><br/>
<b>Exceptions: </b>Throws an exception of type COMPILE-ERROR if the required number of arguments is not supplied. An exception of type INVALID-ARGUMENT is thrown if the first argument is not a list or if the second and third arguments are not non-negative integers. Throws an exception of type INDEX-OUT-OF-BOUNDS if <i>start</i> and <i>len</i> specify a range outside the list size<br/><br/>
<b>Examples:</b><br/><br/>
(sub-list '(1 2 3 4 5) 0 3) => (1 2 3)<br/><br/><b>See Also:</b> 
<a href="#substring">substring</a>, <a href="#sub-array">sub-array</a><hr/>
<a name="substring"></a>
<i>Macro</i><b> substring</b><br/><br/>
<b>Syntax:</b> (substring str start len) => result<br/><br/>
<b>Arguments:</b> str: a form that evaluates to a string; start, end: integers; result: a string<br/><br/>
<b>Description: substring</b> creates a new string comprising the elements starting from position <i>start</i> in <i>str</i> till the position (start + len -1)<br/><br/>
<b>Exceptions: </b>Throws an exception of type COMPILE-ERROR if the required number of arguments is not supplied. An exception of type INVALID-ARGUMENT is thrown if the first argument is not an array (strings are internally stored as arrays in pLisp) or if the second and third arguments are not non-negative integers. Throws an exception of type INDEX-OUT-OF-BOUNDS if <i>start</i> and <i>len</i> specify a range outside the string size<br/><br/>
<b>Examples:</b><br/><br/>
(define x (make-string 3 #\a)) => "aaa"<br/><br/>x => "aaa"<br/><br/>(substring x 0 2) => "aa"<br/><br/><b>See Also:</b> 
<a href="#sub-array">sub-array</a>, <a href="#sub-list">sub-list</a><hr/>
<a name="symbol"></a>
<i>Special Operator</i><b> symbol</b><br/><br/>
<b>Syntax:</b> (symbol str) => result<br/><br/>
<b>Arguments:</b> str: a form that evaluates to a string; result: a symbol<br/><br/>
<b>Description: symbol</b> returns the symbol object represented by <i>str</i>. Note that this operator is case-insensitive<br/><br/>
<b>Exceptions: </b>Throws an exception of type INVALID-ARGUMENT if no arguments are supplied or if the first argument is not a string<br/><br/>
<b>Examples:</b><br/><br/>
(symbol "abc") => ABC<br/><br/><b>See Also:</b> 
<hr/>
<a name="symbol-name"></a>
<i>Special Operator</i><b> symbol-name</b><br/><br/>
<b>Syntax:</b> (symbol-name sym) => result<br/><br/>
<b>Arguments:</b> sym: a form that evaluates to a symbol; result: a string<br/><br/>
<b>Description: symbol</b> returns the string representation of <i>sym</i><br/><br/>
<b>Exceptions: </b>Throws an exception of type COMPILE-ERROR if no arguments are supplied. An exception of type INVALID-ARGUMENT is thrown if the first argument is not a symbol<br/><br/>
<b>Examples:</b><br/><br/>
(symbol-name 'abc) => "ABC"<br/><br/><b>See Also:</b> 
<a href="#symbol-value">symbol-value</a><hr/>
<a name="symbol-value"></a>
<i>Special Operator</i><b> symbol-value</b><br/><br/>
<b>Syntax:</b> (symbol-value sym) => result<br/><br/>
<b>Arguments:</b> sym: a form that evaluates to a symbol; result: an object<br/><br/>
<b>Description: symbol</b> returns the object bound to <i>sym</i> in the current environment<br/><br/>
<b>Exceptions: </b>Throws an exception of type COMPILE-ERROR if no arguments are supplied. An exception of type INVALID-ARGUMENT is thrown if the first argument is not a symbol. Throws SYMBOL-NOT-BOUND if <i>sym</i> is not bound to a value in the top-level environment<br/><br/>
<b>Examples:</b><br/><br/>
(define x 100) => 100<br/><br/>(symbol-value 'x) => 100<br/><br/><b>See Also:</b> 
<a href="#symbol-name">symbol-name</a><hr/>
<a name="symbolp"></a>
<i>Special Operator</i><b> symbolp</b><br/><br/>
<b>Syntax:</b> (symbolp form) => result<br/><br/>
<b>Arguments:</b> form: an object; result: T or NIL<br/><br/>
<b>Description: symbolp</b> returns T if <i>form</i> evaluates to a symbol and NIL otherwise<br/><br/>
<b>Exceptions: </b>Throws an exception of type COMPILE-ERROR if no arguments are supplied<br/><br/>
<b>Examples:</b><br/><br/>
(symbolp 'x) => T<br/><br/>(symbolp #\a) => NIL<br/><br/><b>See Also:</b> 
<hr/>
<a name="third"></a>
<i>Macro</i><b> third</b><br/><br/>
<b>Syntax:</b> (third lst) => result<br/><br/>
<b>Arguments:</b> lst: a list; result: an object<br/><br/>
<b>Description: third</b> returns the third element of a list<br/><br/>
<b>Exceptions: </b>Throws an exception of type COMPILE-ERROR if no arguments are supplied, and an exception of type NOT-A-CONS if <i>lst</i> is not a list<br/><br/>
<b>Examples:</b><br/><br/>
(third '(1 2 3)) => 3<br/><br/>(third ()) => NIL<br/><br/><b>See Also:</b> 
<a href="#caar">caar</a>, <a href="#cadar">cadar</a>, <a href="#cadddr">cadddr</a>, <a href="#caddr">caddr</a>, <a href="#cadr">cadr</a>, <a href="#car">car</a>, <a href="#cdar">cdar</a>, <a href="#cddr">cddr</a>, <a href="#cdr">cdr</a>, <a href="#first">first</a>, <a href="#second">second</a>, <a href="#fourth">fourth</a>, <a href="#fifth">fifth</a><hr/>
<a name="throw"></a>
<i>Special Operator</i><b> throw</b><br/><br/>
<b>Syntax:</b> (throw ex) => NIL<br/><br/>
<b>Arguments:</b> ex: an exception object<br/><br/>
<b>Description: throw</b> throws the exception object specified by <i>ex</i><br/><br/>
<b>Exceptions: </b>Throws an exception of type COMPILE-ERROR if no arguments are supplied, and an exception of type INVALID-ARGUMENT if <i>excp</i> is not a valid exception object<br/><br/>
<b>Examples:</b><br/><br/>
<b>See Also:</b> 
<a href="#error">error</a><hr/>
<a name="time"></a>
<i>Special Operator</i><b> time</b><br/><br/>
<b>Syntax:</b> (time exp) => NIL<br/><br/>
<b>Arguments:</b> exp: a quoted form<br/><br/>
<b>Description: time</b> evaluates <i>exp</i> and prints the time taken for the evaluation. The result is printed to the shell if pLisp was invoked with the <i>-c</i> option and to the Transcript if otherwise<br/><br/>
<b>Exceptions: </b>Throws an EXCEPTION of type COMPILE-ERROR if no arguments are supplied. Propagates exceptions thrown (if any) by the compilation and evaluation of <i>exp</i><br/><br/>
<b>Examples:</b><br/><br/>
(time '(+ 1 1)) =><br/><br/>(+ 1 1) took 0 seconds 20 milliseconds<br/><br/>2<br/><br/><b>See Also:</b> 
<a href="#profile">profile</a><hr/>
<a name="try"></a>
<i>Macro</i><b> try</b><br/><br/>
<b>Syntax:</b> (try body exception-clause finally-clause) => result<br/><br/>
<b>Arguments:</b> body, exception-clause, finally-clause: forms; result: an object<br/><br/>
<b>Description: try</b> evaluates <i>body</i>, and if any exceptions are thrown during this evaluation, evaluates <i>exception-clause</i>. <i>finally-clause</i> is evaluated irrespective of whether an exception is thrown<br/><br/>
<b>Exceptions: </b>Throws an exception of type COMPILE-ERROR if no arguments are supplied or if <i>exception-clause</i> is not of the form <i>(catch (ex) form)</i>. If the exception clause rethrows the exception (or throws a fresh exception), this exception is rethrown by the try<br/><br/>
<b>Examples:</b><br/><br/>
(try (car 1) (catch (e) "Error!") (print "Done")) =><br/><br/>"Done"<br/><br/>"Error!"<br/><br/><b>See Also:</b> 
<a href="#unwind-protect">unwind-protect</a><hr/>
<a name="unbind"></a>
<i>Special Operator</i><b> unbind</b><br/><br/>
<b>Syntax:</b> (unbind sym) => NIL<br/><br/>
<b>Arguments:</b> sym: a qualified symbol<br/><br/>
<b>Description: unbind</b> unbinds <i>sym</i> from the top level environment<br/><br/>
<b>Exceptions: </b>Throws an exception of type COMPILE-ERROR if no arguments are supplied. An exception of type INVALID-ARGUMENT is thrown if the argument is not a symbol. Throws an exception of type SYMBOL-NOT-BOUND if the symbol was not bound already<br/><br/>
<b>Examples:</b><br/><br/>
(unbind 'user:x) => NIL<br/><br/><b>See Also:</b> 
<a href="#define">define</a>, <a href="#set">set</a>, <a href="#setq">setq</a><hr/>
<a name="unwind-protect"></a>
<i>Macro</i><b> unwind-protect</b><br/><br/>
<b>Syntax:</b> (unwind-protect body finally-clause) => result<br/><br/>
<b>Arguments:</b> body, finally-clause: forms; result: an object<br/><br/>
<b>Description: unwind-protect</b> evaluates <i>body</i>, and if any exceptions are thrown during this evaluation, throws the exception. <i>finally-clause</i> is evaluated before the exception is thrown<br/><br/>
<b>Exceptions: </b>Throws an exception of type COMPILE-ERROR if the required number of arguments is not supplied. Rethrows any exception thrown during the evaluation of <i>body</i><br/><br/>
<b>Examples:</b><br/><br/>
(unwind-protect (car 1) (print "Done"))<br/><br/><b>See Also:</b> 
<a href="#try">try</a><hr/>
<a name="values"></a>
<i>Macro</i><b> values</b><br/><br/>
<b>Syntax:</b> (values &rest body) => result<br/><br/>
<b>Arguments:</b> body: the arguments converted to a list; result: a list<br/><br/>
<b>Description: values</b> bundles the arguments into a list. It is used to return multiple values from an expression<br/><br/>
<b>Exceptions: </b>None<br/><br/>
<b>Examples:</b><br/><br/>
(values 1 2 3) => (1 2 3)<br/><br/><b>See Also:</b> 
<a href="#multiple-value-bind">multiple-value-bind</a><hr/>
<a name="while"></a>
<i>Macro</i><b> while</b><br/><br/>
<b>Syntax:</b> (while cond &rest body) => result<br/><br/>
<b>Arguments:</b> cond: a form; body: the rest of the arguments converted to a list; result: an object<br/><br/>
<b>Description: while</b> evaluates <i>body</i> while <i>cond</i> evaluates to a non-NIL value. The result of evaluating <i>body</i> for the last time is returned<br/><br/>
<b>Exceptions: </b>Throws an exception of type COMPILE-ERROR if the required number of arguments is not supplied. Propagates exceptions (if any) thrown by its constituent forms<br/><br/>
<b>Examples:</b><br/><br/>
(let ((x 0)) (while (< x 5) (print x) (incf x))) =><br/><br/>0<br/><br/>1<br/><br/>2<br/><br/>3<br/><br/>4<br/><br/>NIL<br/><br/><b>See Also:</b> 
<hr/>
<a name="-"></a>
<i>Special Operator</i><b> -</b><br/><br/>
<b>Syntax:</b> (- form*) => result<br/><br/>
<b>Arguments:</b> form: a form that evaluates to an integer or a float; result: an integer or a float<br/><br/>
<b>Description: -</b> subtracts the sum of the remaining arguments from the first argument<br/><br/>
<b>Exceptions: </b>Throws an exception of type COMPILE-ERROR if at least two arguments are not supplied. An exception of type INVALID-ARGUMENT is thrown if any of the arguments is not an integer or a float<br/><br/>
<b>Examples:</b><br/><br/>
(- 2 1) => 1<br/><br/>(- 10 2 3.14) => 4.860000<br/><br/><b>See Also:</b> 
<hr/>
<a name=","></a>
<i>Special Operator</i><b> ,</b><br/><br/>
<b>Syntax:</b> ,form => result<br/><br/>
<b>Arguments:</b> form: a form; result: an object<br/><br/>
<b>Description: ,</b> is used in macro bodies to represent forms whose values should be substituted in the compiled form<br/><br/>
<b>Exceptions: </b>Throws an exception of type COMPILE-ERROR if invoked outside the context of function/macro definitions<br/><br/>
<b>Examples:</b><br/><br/>
(defmacro first (lst) `(car ,lst)) => <macro><br/><br/><b>See Also:</b> 
<hr/>
<a name=",@"></a>
<i>Special Operator</i><b> ,@</b><br/><br/>
<b>Syntax:</b> ,@form => result<br/><br/>
<b>Arguments:</b> form: a form; result: an object<br/><br/>
<b>Description: ,@</b> is used in macro bodies to splice the forms (whose values are lists) into a list in the compiled form<br/><br/>
<b>Exceptions: </b>Throws an exception of type COMPILE-ERROR if invoked outside the context of function/macro definitions<br/><br/>
<b>Examples:</b><br/><br/>
(defmacro values (&rest body) `(list ,@body))<br/><br/><b>See Also:</b> 
<hr/>
<a name="*"></a>
<i>Special Operator</i><b> *</b><br/><br/>
<b>Syntax:</b> (* form*) => result<br/><br/>
<b>Arguments:</b> form: a form that evaluates to an integer or a float; result: an integer or a float<br/><br/>
<b>Description: *</b> multiplies all its arguments<br/><br/>
<b>Exceptions: </b>Throws an exception of type COMPILE-ERROR if at least two arguments are not supplied. An exception of type INVALID-ARGUMENT is thrown if any of the arguments is not an integer or a float<br/><br/>
<b>Examples:</b><br/><br/>
(* 2 1) => 2<br/><br/>(* 1 2 3) => 6<br/><br/><b>See Also:</b> 
<hr/>
<a name="/"></a>
<i>Special Operator</i><b> /</b><br/><br/>
<b>Syntax:</b> (/ form*) => result<br/><br/>
<b>Arguments:</b> form: a form that evaluates to an integer or a float; result: an integer or a float<br/><br/>
<b>Description: /</b> divides the first argument by the product of the remaining arguments. If all the arguments are integers, integer division is performed, otherwise floating point division is performed<br/><br/>
<b>Exceptions: </b>Throws an exception of type COMPILE-ERROR if at least two arguments are not supplied. An exception of type INVALID-ARGUMENT is thrown if any of the arguments is not an integer or a float. An exception DIV-BY-ZERO-EXCEPTION is thrown if a division by zero is attempted<br/><br/>
<b>Examples:</b><br/><br/>
(/ 2 1) => 2<br/><br/>(/ 1.0 2 3) => 0.166667<br/><br/><b>See Also:</b> 
<hr/>
<a name="`"></a>
<i>Special Operator</i><b> `</b><br/><br/>
<b>Syntax:</b> `form => result<br/><br/>
<b>Arguments:</b> form: a form; result: an object<br/><br/>
<b>Description: `</b> is used in macro bodies to represent forms that should be carried over as-is to the compiled form<br/><br/>
<b>Exceptions: </b>None<br/><br/>
<b>Examples:</b><br/><br/>
(defmacro first (lst) `(car ,lst)) => <macro><br/><br/><b>See Also:</b> 
<a href="#'">'</a><hr/>
<a name="'"></a>
<i>Special Operator</i><b> '</b><br/><br/>
<b>Syntax:</b> 'form => result<br/><br/>
<b>Arguments:</b> form: a form; result: an object<br/><br/>
<b>Description: '</b> is used to quote a form, i.e. prevent pLisp from evaluating the form and instead return it as-is<br/><br/>
<b>Exceptions: </b>None<br/><br/>
<b>Examples:</b><br/><br/>
'(a b c) => (a b c)<br/><br/><b>See Also:</b> 
<a href="#`">`</a><hr/>
<a name="+"></a>
<i>Special Operator</i><b> +</b><br/><br/>
<b>Syntax:</b> (+ form*) => result<br/><br/>
<b>Arguments:</b> form: a form that evaluates to an integer or a float; result: an integer or a float<br/><br/>
<b>Description: +</b> computes the sum of its arguments<br/><br/>
<b>Exceptions: </b>Throws an exception of type COMPILE-ERROR if at least two arguments are not supplied. An exception of type INVALID-ARGUMENT is thrown if any of the arguments is not an integer or a float<br/><br/>
<b>Examples:</b><br/><br/>
(+ 1 2) => 3<br/><br/>(+ 1 3.14) => 4.140000<br/><br/><b>See Also:</b> 
<hr/>
<a name="<"></a>
<i>Special Operator</i><b> <</b><br/><br/>
<b>Syntax:</b> (< form1 form2) => result<br/><br/>
<b>Arguments:</b> form1, form2: forms that evaluates to integers or floats; result: T or NIL<br/><br/>
<b>Description: <</b> returns T if <i>form1</i> is less than <i>form2</i> and NIL otherwise<br/><br/>
<b>Exceptions: </b>Throws an exception of type COMPILE-ERROR if exactly two arguments are not supplied. An exception of type INVALID-ARGUMENT is thrown if either of the arguments is not an integer or a float<br/><br/>
<b>Examples:</b><br/><br/>
(< 1 2) => T<br/><br/>(< 2 1) => NIL<br/><br/><b>See Also:</b> 
<a href="#<="><=</a><hr/>
<a name="<="></a>
<i>Special Operator</i><b> <=</b><br/><br/>
<b>Syntax:</b> (<= form1 form2) => result<br/><br/>
<b>Arguments:</b> form1, form2: forms that evaluates to integers or floats; result: T or NIL<br/><br/>
<b>Description: <=</b> returns T if <i>form1</i> is less than or equal to <i>form2</i> and NIL otherwise<br/><br/>
<b>Exceptions: </b>Throws an exception of type COMPILE-ERROR if exactly two arguments are not supplied. An exception of type INVALID-ARGUMENT is thrown if either of the arguments is not an integer or a float<br/><br/>
<b>Examples:</b><br/><br/>
(<= 1 2) => T<br/><br/>(<= 2 2) => T<br/><br/>(<= 4 3) => NIL<br/><br/><b>See Also:</b> 
<a href="#<"><</a><hr/>
<a name=">"></a>
<i>Special Operator</i><b> ></b><br/><br/>
<b>Syntax:</b> (> form1 form2) => result<br/><br/>
<b>Arguments:</b> form1, form2: forms that evaluates to integers or floats; result: T or NIL<br/><br/>
<b>Description: ></b> returns T if <i>form1</i> is greater than <i>form2</i> and NIL otherwise<br/><br/>
<b>Exceptions: </b>Throws an exception of type COMPILE-ERROR if exactly two arguments are not supplied. An exception of type INVALID-ARGUMENT is thrown if either of the arguments is not an integer or a float<br/><br/>
<b>Examples:</b><br/><br/>
(> 2 1) => T<br/><br/>(> 2 7) => NIL<br/><br/><b>See Also:</b> 
<a href="#>=">>=</a><hr/>
<a name=">="></a>
<i>Special Operator</i><b> >=</b><br/><br/>
<b>Syntax:</b> (>= form1 form2) => result<br/><br/>
<b>Arguments:</b> form1, form2: forms that evaluates to integers or floats; result: T or NIL<br/><br/>
<b>Description: >=</b> returns T if <i>form1</i> is greater than or equal to <i>form2</i> and NIL otherwise<br/><br/>
<b>Exceptions: </b>Throws an exception of type COMPILE-ERROR if exactly two arguments are not supplied. An exception of type INVALID-ARGUMENT is thrown if either of the arguments is not an integer or a float<br/><br/>
<b>Examples:</b><br/><br/>
(>= 7 2) => T<br/><br/>(>= 1 2) => NIL<br/><br/>(>= 1 1) => T<br/><br/><b>See Also:</b> 
<a href="#>">></a><hr/>
<a name="inspect-object"></a>
<i>Special Operator</i><b> inspect-object</b><br/><br/>
<b>Syntax:</b> (inspect-object obj) => NIL<br/><br/>
<b>Arguments:</b> obj: a pLisp object<br/><br/>
<b>Description: inspect-object</b> invokes the pLisp Object Inspector and displays the type, structure, and contents of the object passed as its argument<br/><br/>
<b>Exceptions: </b>Throws an exception of type COMPILE-ERROR if exactly one argument is not supplied<br/><br/>
<b>Examples:</b><br/><br/>
(inspect-object (cons 1 2))  => NIL<br/><br/><b>See Also:</b> 
<hr/>
<a name="step"></a>
<i>Special Operator</i><b> step</b><br/><br/>
<b>Syntax:</b> (step exp) => result<br/><br/>
<b>Arguments:</b> exp: a pLisp source expression<br/><br/>
<b>Description: step</b> invokes the pLisp Stepper UI and interactively steps through the expression passed as its argument<br/><br/>
<b>Exceptions: </b>Throws an exception of type COMPILE-ERROR if exactly one argument is not supplied<br/><br/>
<b>Examples:</b><br/><br/>
(step (+ 1 2))  => 3<br/><br/><b>See Also:</b> 
<hr/>
</body>
</html>
