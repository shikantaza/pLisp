{"entries" :
 [
  {"type" : 2, 
   "name" : "abort", 
   "syntax" : "(abort) => NIL",
   "args" : "None",
   "desc" : "abort aborts the evaluation of an expression when in debug mode",
   "exceptions" : "None; an error is raised if abort is invoked when not in debug mode (entered via a 'break')",
   "examples" : [ ],
   "see-also" : [ "break", "resume" ]
  },

  {"type" : 1, 
   "name" : "alias", 
   "syntax" : "(alias var1 var2) => NIL",
   "args" : "var1, var2: symbols",
   "desc" : "alias creates a new binding between 'var2' and the object bound to 'var1'",
   "exceptions" : "Throws an exception of type COMPILE-ERROR if no arguments are supplied. An exception of type INVALID-ARGUMENT is thrown if 'var1' is not a symbol",
   "examples"   : [ "(define x 100)", "(alias y x)", "y=>100" ],
   "see-also" : [ "define" ]
  },

  {"type" : 1, 
   "name" : "and", 
   "syntax" : "(and form*) => result",
   "args" : "form: an object; result: T or NIL",
   "desc" : "and performs a logical conjunction of its operands. Returns T if all the operands evaluate to non-NIL and NIL otherwise. Returns T if no arguments are passed",
   "exceptions" : "None",
   "examples" : [ "(and (eq 1 1) (eq 2 2)) => T", "(and () 3) => NIL" ],
   "see-also" : [ "or" ]
  },

  {"type" : 0, 
   "name" : "append", 
   "syntax" : "(append list1 list2) => result",
   "args" : "list1, list2: forms that evaluate to lists; result: a list",
   "desc" : "append creates a new list by appending the two lists passed as arguments",
   "exceptions" : "Throws an exception of type COMPILE-ERROR if the required number of argument are not supplied, and an exception of type EXCEPTION if either of the arguments is not a list",
   "examples" : [ "(append '(a b) '(c d)) => (A B C D)", "(append () '(1 2)) => (1 2)" ],
   "see-also" : [ "concat", "nconc" ]
  },

  {"type" : 2, 
   "name" : "apply", 
   "syntax" : "(apply function args) => result",
   "args" : "function: a form that evaluates to a function or a continuation; args: a form that evaluates to a list; result: an object",
   "desc" : "apply applies the function or continuation passed as its first parameter to the arguments passed as its second parameter",
   "exceptions" : "Throws an exception of type COMPILE-ERROR if two arguments are not passed; throws an exception of type INVALID-ARGUMENT if the first argument is not a function or a continuation or if the second argument is not a list",
   "examples" : [ "(apply (lambda (a b) (+ a b)) '(1 2)) => 3" ],
   "see-also" : [ "funcall" ]
  },

  {"type" : 1, 
   "name" : "array", 
   "syntax" : "(array dims default-value) => result",
   "args" : "dims: a list; default-value: an object; result: an array object",
   "desc" : "array creates an array with the dimensions specified by the list 'dims' and populates the elements of the newly-constructed array with 'default-value'",
   "exceptions" : "Throws an exception of type COMPILE-ERROR if the required number of argument are not supplied, and INVALID-ARGUMENT if the argument type(s) are not as indicated",
   "examples" : [ "(define a (array (2 2) 1)) => [[1 1] [1 1]]" ],
   "see-also" : [  ]
  },

  {"type" : 0, 
   "name" : "array-eq", 
   "syntax" : "(array-eq arr1 arr1) => result",
   "args" : "arr1, arr2: forms that evaluate to array objects; result: T or NIL",
   "desc" : "array-eq returns T if 'arr1' and 'arr2' are structurally equivalent, i.e. they have the same contents, and NIL otherwise",
   "exceptions" : "Throws an exception of type COMPILE-ERROR if the required number/types of argument are not supplied, and INVALID-ARGUMENT if either of the arguments is not an array",
   "examples" : [ "a1 => [1, 2]", "a2 => [1, 2]", "a3 => ['a 'b]", "(array-eq a1 a2) => T", "(array-eq a1 a3) => NIL" ],
   "see-also" : [ "eq" ]
  },

  {"type" : 2, 
   "name" : "array-get", 
   "syntax" : "(array-get arr index) => result",
   "args" : "arr: a form that evaluates to an array object; index: a form that evaluates to an integer; result: an object",
   "desc" : "array-get returns the object at the position 'index' of array 'arr'. Note that array indices start from zero",
   "exceptions" : "Throws an exception of type COMPILE-ERROR if the required number of arguments are not supplied. Throws an exception of type INVALID-ARGUMENT if the first argument is not an array, and an exception of type INDEX-OUT-OF-BOUNDS if the index is less than zero or greater than '(len-1)', where 'len' is the length of the array",
   "examples" : [ "a1 => [1, 2]", "(array-get a1 0) => 1" ],
   "see-also" : [ "array-set", "string-get", "string-set" ]
  },

  {"type" : 2, 
   "name" : "array-length", 
   "syntax" : "(array-length arr) => result",
   "args" : "arr: a form that evaluates to an array object; result: an integer",
   "desc" : "array-length returns the length of array 'arr'",
   "exceptions" : "Throws an exception of type COMPILE-ERROR if the required number of arguments are not supplied, and an exception of type INVALID-ARGUMENT if the first argument is not an array",
   "examples" : [ "a1 => [40, 50]", "(array-length a1) => 2" ],
   "see-also" : [ "length" ]
  },

  {"type" : 2, 
   "name" : "array-set", 
   "syntax" : "(array-set arr index form) => form",
   "args" : "arr: a form that evaluates to an array object; index: an integer; form: an object",
   "desc" : "array-set binds the position 'index' of array 'arr' to 'form'",
   "exceptions" : "Throws an exception of type COMPILE-ERROR if the required number of arguments are not supplied. Throws an exception of type INVALID-ARGUMENT if the first argument is not an array, and an exception of type INDEX-OUT-OF-BOUNDS if the index is less than zero or greater than '(len-1)', where 'len' is the length of the array",
   "examples" : [ "a1 => [40, 50]", "(array-set a1 0 30) => 30", "a1 => [30, 50]" ],
   "see-also" : [ "array-get", "string-get", "string-set" ]
  },

  {"type" : 2, 
   "name" : "arrayp", 
   "syntax" : "(arrayp form) => result",
   "args" : "form: an object; result: T or NIL",
   "desc" : "arrayp returns T if form evaluates to an array and NIL otherwise",
   "exceptions" : "Throws an exception of type COMPILE-ERROR if no arguments are supplied",
   "examples" : [ "a1 => [40, 50]", "(arrayp a1) => T", "(arrayp 10) => NIL" ],
   "see-also" : []
  },

  {"type" : 1, 
   "name" : "aset", 
   "syntax" : "(aset ref val) => val",
   "args" : "ref: an array reference; val: an object",
   "desc" : "aset binds 'val' to the array location referred to by 'ref'",
   "exceptions" : "Throws an exception of type SYMBOL-NOT-BOUND if the array reference is not bound to an array object, and an exception INDEX-OUT-OF-BOUNDS if the index(es) in the reference fall outside the array bounds. An exception of type COMPILE-ERROR is thrown if the required number of arguments are not supplied",
   "examples" : [ "(define a (array (2 2) 0) => [[0 0] [0 0]]", "a => [[0 0] [0 0]]", "(aset a[0 0] 100) => 100", "a => [[100 0] [0 0]]" ],
   "see-also" : []
  },

  {"type" : 1, 
   "name" : "assert", 
   "syntax" : "(assert form) => NIL",
   "args" : "form: an object",
   "desc" : "assert throws an exception of type EXCEPTION if form evaluates to NIL",
   "exceptions" : "Throws an exception of type COMPILE-ERROR if the no arguments are supplied",
   "examples" : [],
   "see-also" : [ ]
  },

  {"type" : 0, 
   "name" : "assoc", 
   "syntax" : "(assoc key pairs) => result",
   "args" : "key: an object; pairs: a list of CONS objects; result: object",
   "desc" : "assoc returns the CDR of the pair in 'pairs' whose CAR equals 'key' and NIL otherwise",
   "exceptions" : "Throws an exception of type COMPILE-ERROR if the required number of arguments are not supplied. Throws an exception of type EXCEPTION if 'pairs' is not a list of CONS objects",
   "examples" : ["a => ((1 . x) (2 . y))", "(assoc 1 a) => x", "(assoc 3 a) => NIL"],
   "see-also" : [ ]
  },

  {"type" : 2, 
   "name" : "atom", 
   "syntax" : "(atom form) => result",
   "args" : "form: an object; result: T or NIL",
   "desc" : "atom returns T if 'form' is an atom and NIL otherwise",
   "exceptions" : "Throws an exception of type COMPILE-ERROR if no arguments are supplied",
   "examples" : [ "(atom 1) => T", "(atom '(1 2)) => NIL" ],
   "see-also" : []
  },

  {"type" : 2, 
   "name" : "break", 
   "syntax" : "(break) => NIL",
   "args" : "None",
   "desc" : "break stops the evaluation of the expression and passes control to the debugger",
   "exceptions" : "None",
   "examples" : [ ],
   "see-also" : [ "abort", "resume" ]
  },

  {"type" : 0, 
   "name" : "butlast", 
   "syntax" : "(butlast lst len) => result",
   "args" : "lst: a form that evaluates to a list; len: an integer; result: a list",
   "desc" : "butlast returns a list that comprises the elements of 'lst' excluding the last 'len' elements",
   "exceptions" : "Throws an exception of type COMPILE-ERROR if the required number of arguments are not supplied. Throws an exception of type EXCEPTION if lst is not a list or len is not a positive integer smaller than the length of lst",
   "examples" : [ "(butlast '(1 2 3) 1) => (1 2)" ],
   "see-also" : [ "last", "last-n"]
  },

  {"type" : 0, 
   "name" : "caar", 
   "syntax" : "(caar lst) => result",
   "args" : "lst: a form that evaluates to a list; result: an object",
   "desc" : "caar is functionally equivalent to (car (car lst)",
   "exceptions" : "Throws an exception of type COMPILE-ERROR if no arguments are supplied. Throws an exception of type EXCEPTION if either of the applications of car above is not on a list",
   "examples" : [ "(caar '((1 2) (3 4)) => 1" ],
   "see-also" : [ "cadar", "cadddr", "caddr", "cadr", "car", "cdar", "cddr", "cdr", "first", "second", "third", "fourth", "fifth"  ]
  },

  {"type" : 0, 
   "name" : "cadar", 
   "syntax" : "(cadar lst) => result",
   "args" : "lst: a form that evaluates to a list; result: an object",
   "desc" : "cadar is functionally equivalent to (car (cdr (car lst))",
   "exceptions" : "Throws an exception of type COMPILE-ERROR if no arguments are supplied. Throws an exception of type EXCEPTION if any of the applications of car or cdr above is not on a list",
   "examples" : [ "(cadar '((1 2) (3 4)) => 2" ],
   "see-also" : [ "caar", "cadddr", "caddr", "cadr", "car", "cdar", "cddr", "cdr", "first", "second", "third", "fourth", "fifth" ]
  },

  {"type" : 0, 
   "name" : "cadddr", 
   "syntax" : "(cadddr lst) => result",
   "args" : "lst: a form that evaluates to a list; result: an object",
   "desc" : "cadddr is functionally equivalent to (car (cdr (cdr (cdr lst)))), i.e., the fourth element of a list",
   "exceptions" : "Throws an exception of type COMPILE-ERROR if no arguments are supplied. Throws an exception of type EXCEPTION if any of the applications of car or cdr above is not on a list",
   "examples" : [ "(cadddr '(1 2 3 4)) => 4" ],
   "see-also" : [ "caar", "cadar", "caddr", "cadr", "car", "cdar", "cddr", "cdr", "first", "second", "third", "fourth", "fifth" ]
  },

  {"type" : 0, 
   "name" : "caddr", 
   "syntax" : "(caddr lst) => result",
   "args" : "lst: a form that evaluates to a list; result: an object",
   "desc" : "caddr is functionally equivalent to (car (cdr (cdr lst))), i.e., the third element of a list",
   "exceptions" : "Throws an exception of type COMPILE-ERROR if no arguments are supplied. Throws an exception of type EXCEPTION if any of the applications of car or cdr above is not on a list",
   "examples" : [ "(caddr '(1 2 3 4)) => 3" ],
   "see-also" : [ "caar", "cadar", "cadddr", "cadr", "car", "cdar", "cddr", "cdr", "first", "second", "third", "fourth", "fifth" ]
  },

  {"type" : 0, 
   "name" : "cadr", 
   "syntax" : "(cadr lst) => result",
   "args" : "lst: a form that evaluates to a list; result: an object",
   "desc" : "cadr is functionally equivalent to (car (cdr lst)), i.e., the second element of a list",
   "exceptions" : "Throws an exception of type COMPILE-ERROR if no arguments are supplied. Throws an exception of type EXCEPTION if either of the applications of car or cdr above is not on a list",
   "examples" : [ "(cadr '(1 2 3 4)) => 2" ],
   "see-also" : [ "caar", "cadar", "cadddr", "caddr", "car", "cdar", "cddr", "cdr", "first", "second", "third", "fourth", "fifth" ]
  },

  {"type" : 1, 
   "name" : "call-foreign-function", 
   "syntax" : "(call-foreign-function name return-type params) => result",
   "args" : "name: a form that evaluates to a string; return-type: a symbol; params: a list of CONS objects; result: an object",
   "desc" : "call-foreign-function invokes a native function called name defined in a shared library that was loaded earlier. 'return-type' denotes the return type of the native function (void, integer, float, character, or character-pointer). 'params' contains information about the parameters to the native function (parameter type and object)",
   "exceptions" : "call-foreign-function throws an exception of type COMPILE-ERROR if the required number of arguments is not supplied.  It throws an exception of type ARG-MISMATCH if the parameters are not of the types as described above. ARG-MISMATCH is also thrown if there are any inconsistencies in the params argument (e.g. the parameter type is integer and the object is not an integer)",
   "examples" : [ "(call-foreign-function some_func void ((ivar integer, fvar float)))" ],
   "see-also" : [ "load-foreign-library" ]
  },

  {"type" : 2, 
   "name" : "call/cc", 
   "syntax" : "(call/cc lambda-exp) => result",
   "args" : "lambda-exp: a form; result: an object",
   "desc" : "call/cc captures the current continuation object and invokes the function object 'lambda-exp' with this continuation object as the parameter",
   "exceptions" : "Throws an exception of type COMPILE-ERROR if no arguments are supplied.",
   "examples" : [ "(call/cc (lambda (cc) (set cont cc)))" ],
   "see-also" : []
  },

  {"type" : 2, 
   "name" : "car", 
   "syntax" : "(car lst) => result",
   "args" : "lst: a form that evaluates to a list; result: an object",
   "desc" : "car returns the first element of a list",
   "exceptions" : "Throws an exception of type COMPILE-ERROR if no arguments are supplied. Throws an exception of type NOT-A-CONS if the argument is not a list",
   "examples" : [ "(car '(1 2 3 4)) => 1", "(car nil) => NIL" ],
   "see-also" : [ "caar", "cadar", "cadddr", "caddr", "cadr", "cdar", "cddr", "cdr", "first", "second", "third", "fourth", "fifth" ]
  },

  {"type" : 0, 
   "name" : "cdar", 
   "syntax" : "(cdar lst) => result",
   "args" : "lst: a form that evaluates to a list; result: an object",
   "desc" : "cdar is functionally equivalent to (cdr (car lst))",
   "exceptions" : "Throws an exception of type COMPILE-ERROR if no arguments are supplied. Throws an exception of type EXCEPTION if either of the applications of car or cdr above is not on a list",
   "examples" : [ "(cdar '((1 2) 3 4)) => (2)" ],
   "see-also" : [ "caar", "cadar", "cadddr", "caddr", "cadr", "car", "cddr", "cdr", "first", "second", "third", "fourth", "fifth" ]
  },

  {"type" : 0, 
   "name" : "cddr", 
   "syntax" : "(cddr lst) => result",
   "args" : "lst: a form that evaluates to a list; result: an object",
   "desc" : "cddr is functionally equivalent to (cdr (cdr lst))",
   "exceptions" : "Throws an exception of type COMPILE-ERROR if no arguments are supplied. Throws an exception of type EXCEPTION if either of the applications of cdr above is not on a list",
   "examples" : [ "(cddr '(1 2 3 4)) => (3 4)" ],
   "see-also" : [ "caar", "cadar", "cadddr", "caddr", "cadr", "car", "cdar", "cdr", "first", "second", "third", "fourth", "fifth" ]
  },

  {"type" : 2, 
   "name" : "cdr", 
   "syntax" : "(cdr lst) => result",
   "args" : "lst: a form that evaluates to a list; result: an object",
   "desc" : "cdr returns the list comprising the all the elements of 'lst' except the first one",
   "exceptions" : "Throws an exception of type COMPILE-ERROR if no arguments are supplied. Throws an exception of type EXCEPTION if lst is not a list",
   "examples" : [ "(cdr '(1 2 3 4)) => (2 3 4)" ],
   "see-also" : [ "caar", "cadar", "cadddr", "caddr", "cadr", "car", "cdar", "cddr", "first", "second", "third", "fourth", "fifth" ]
  },

  {"type" : 2, 
   "name" : "characterp", 
   "syntax" : "(characterp form) => result",
   "args" : "form: an object; result: T or NIL",
   "desc" : "characterp returns T if 'form' evaluates to a character and NIL otherwise",
   "exceptions" : "Throws an exception of type COMPILE-ERROR if no arguments are supplied",
   "examples" : [ "(characterp #\\a) => T", "(characterp 10) => NIL" ],
   "see-also" : [ ]
  },

  {"type" : 2, 
   "name" : "clone", 
   "syntax" : "(clone form) => result",
   "args" : "form: an object; result: an object",
   "desc" : "clone makes a deep copy of the object 'form' evaluates to",
   "exceptions" : "Throws an exception of type COMPILE-ERROR if no arguments are supplied",
   "examples" : [ "(clone '(1 2 3)) => (1 2 3)" ],
   "see-also" : [  ]
  },

  {"type" : 2, 
   "name" : "closurep", 
   "syntax" : "(closurep form) => result",
   "args" : "form: an object; result: T or NIL",
   "desc" : "closurep returns T if form evaluates to a function object and NIL otherwise. Note that special operators are not closures",
   "exceptions" : "Throws an exception of type COMPILE-ERROR if no arguments are supplied",
   "examples" : [ "(closurep (lambda (x) x)) => T", "(defun double (n) (* n 2)) => <function>", "(closurep double) => T", "(closurep 3) => NIL"  ],
   "see-also" : []
  },

  {"type" : 0, 
   "name" : "concat", 
   "syntax" : "(concat lst &rest lists) => result",
   "args" : "lst: a list; lists: a list of the rest of the arguments, which are themselves lists",
   "desc" : "concat combines the passed lists into a new list",
   "exceptions" : "Throws an exception of type COMPILE-ERROR if no arguments are supplied. An exception of type INVALID-ARGUMENT is thrown if any of its arguments is not a list",
   "examples" : [ "(concat '(1 2 3) '(4 5 6) '(7 8 9)) => '(1 2 3 4 5 6 7 8 9)" ],
   "see-also" : [ "append", "concat-strings", "nconc" ]
  },

  {"type" : 0, 
   "name" : "concat-strings", 
   "syntax" : "(concat-strings str1 str2) => result",
   "args" : "str1, str2: forms that evaluate to strings; result: a string",
   "desc" : "concat-strings combines the two strings passed as arguments into a new string",
   "exceptions" : "Throws an exception of type COMPILE-ERROR if the required number of argument are not supplied, and an exception of type INVALID-ARGUMENT if either of the two arguments is not a string",
   "examples" : [ "(concat-strings \"abc\" \"def\") => \"abcdef\"" ],
   "see-also" : [ "concat" ]
  },

  {"type" : 1, 
   "name" : "cond", 
   "syntax" : "(cond ((cond1 action1) (cond2 action2) ..)) => result",
   "args" : "cond1, cond2, …: forms; action1, action2, …: forms; result: an object",
   "desc" : "cond takes a list comprising condition/action pairs, and evaluates each condition sequentially, stopping at the first condition that evaluates to a non-NIL value. It then evaluates the action corresponding to this condition and returns the result of evaluating that action. If none of the conditions evaluates to a non-NIL value, cond returns NIL. If the last condition is T, the action corresponding to this serves as the default action",
   "exceptions" : "Throws an exception of type COMPILE-ERROR if the required number of argument are not supplied",
   "examples" : [ "(cond ((eq 1 1) 'true) (t 'false)) => TRUE" ],
   "see-also" : [ "if" ]
  },

  {"type" : 2, 
   "name" : "cons", 
   "syntax" : "(cons obj1 obj2) => result",
   "args" : "obj1, obj2 : objects; result:a CONS object",
   "desc" : "cons creates a CONS object from the two objects passed to it as arguments",
   "exceptions" : "Throws an exception of type COMPILE-ERROR if the required number of argument are not supplied",
   "examples" : [ "(cons 1 2) => (1 . 2)", "(cons 'a nil) => (A)" ],
   "see-also" : [  ]
  },

  {"type" : 0, 
   "name" : "cons-pair", 
   "syntax" : "(cons-pair list1 list2) => result",
   "args" : "list1, list2: forms that evaluate to lists; result: a list",
   "desc" : "cons-pair takes two lists and creates a new list, the elements of which are CONS objects obtained by applying cons on the matched elements of the two lists. If the sizes of the two lists are not the same, the shorter of the two lists is padded with NIL values",
   "exceptions" : "Throws an exception of type COMPILE-ERROR if the required number of argument are not supplied, and an exception of type INVALID-ARGUMENT if either of its arguments is not a list",
   "examples" : [ "(cons-pair '(a b) '(1 2)) => ((A . 1) (B . 2))", "(cons-pair '(a b c) '(1 2)) => ((A . 1) (B . 2) (C))" ],
   "see-also" : [ "pair" ]
  },

  {"type" : 2, 
   "name" : "consp", 
   "syntax" : "(consp form) => result",
   "args" : "form: an object; result: T or NIL",
   "desc" : "consp returns T if 'form' evaluates to a CONS object and NIL otherwise",
   "exceptions" : "Throws an exception of type COMPILE-ERROR if no arguments are supplied",
   "examples" : [ "(define a (cons 1 2)) => (1 . 2)", "(consp a) => T", "(consp 10) => NIL" ],
   "see-also" : [  ]
  },

  {"type" : 2, 
   "name" : "continuationp", 
   "syntax" : "(continuationp form) => result",
   "args" : "form: an object; result: T or NIL",
   "desc" : "continuationp returns T if 'form' evaluates to a continuation object and NIL otherwise",
   "exceptions" : "Throws an exception of type COMPILE-ERROR if no arguments are supplied",
   "examples" : [ "(define cont nil) => NIL", "(progn (call/cc (lambda (cc) (set cont cc))) (print 1)) =>", "1", "1", "(continuationp cont) => T" ],
   "see-also" : [  ]
  },

  {"type" : 2, 
   "name" : "create-image", 
   "syntax" : "(create-image file-name) => result",
   "args" : "file-name: a string object; result: NIL",
   "desc" : "create-image saves the current state of the pLisp system to a file called 'file-name'",
   "exceptions" : "Throws an exception of type COMPILE-ERROR if no arguments are passed, and an exception of type INVALID-ARGUMENT if the argument is not a string object",
   "examples" : [ "(create-image \"plisp.image\") => NIL" ],
   "see-also" : [ "load-object", "save-object" ]
  },

  {"type" : 2, 
   "name" : "create-package", 
   "syntax" : "(create-package package-name) => result",
   "args" : "package-name: string; result: string",
   "desc" : "create-package creates a new package with the name 'package-name'. It returns the name of the newly-created package",
   "exceptions" : "Throws an exception of type COMPILE-ERROR if no arguments are passed, and an exception of type INVALID-ARGUMENT if the argument is not a string object. An exception of type PACKAGE-ALREADY-EXISTS is thrown if the package with name package-name already exists",
   "examples" : [ "(create-package \"pkg\") => \"PKG\"" ],
   "see-also" : [ "export-package", "in-package", "import-package" ]
  },

  {"type" : 2, 
   "name" : "define", 
   "syntax" : "(define var form) => var",
   "args" : "var: a symbol; form: a form; result: NIL",
   "desc" : "define evaluates 'form' and binds the result of this evaluation to 'var' in the top-level environment",
   "exceptions" : "Throws en exception of type INVALID-ARGUMENT if var is not a symbol",
   "examples" : [ "(define x 100) => 100", "x => 100" ],
   "see-also" : [ "alias" ]
  },

  {"type" : 1, 
   "name" : "defmacro", 
   "syntax" : "(defmacro name params &rest body) => result",
   "args" : "name: symbol; params: list; body: the rest of the arguments converted into a list; result: a macro object",
   "desc" : "defmacro creates a macro named 'name' with parameters 'params' and body 'body'. An optional string can be passed after 'params' to document the macro.",
   "exceptions" : "Throws an exception of type COMPILE-ERROR if the required number of parameters is not supplied. Propagates exceptions thrown (if any) by the underlying macro expansion.",
   "examples" : [ "(defmacro first (lst) `(car ,lst)) => <macro>" ],
   "see-also" : [ "macro" ]
  },

  {"type" : 1, 
   "name" : "defun", 
   "syntax" : "(defun name params &rest body) => result",
   "args" : "name: symbol; params: list; body: the rest of the arguments converted into a list; result: a function object",
   "desc" : "defun creates a function named 'name' with parameters 'params' and body 'body'. An optional string can be passed after 'params' to document the function.",
   "exceptions" : "Throws an exception of type COMPILE-ERROR if the required number of parameters is not supplied. Propagates exceptions thrown (if any) by the underlying macro expansion.",
   "examples" : [ "(defun double (n) (* n 2)) => <function>" ],
   "see-also" : [ "lambda" ]
  },

  {"type" : 1, 
   "name" : "def-curry-fn", 
   "syntax" : "(def-curry-fn f1 f0 &rest args) => result",
   "args" : "f1: a symbol; f0: a function; args: a list of the rest of the arguments; result: a function",
   "desc" : "def-curry-fn takes a symbol, a function object and a partial list of the arguments to the function, and binds the symbol to a function object which takes as arguments the remaining list of the arguments of the given function object. The returned function object invokes the given function object with the parameters comprising the partial list and the supplied parameters list",
   "exceptions" : "Throws an exception of type COMPILE-ERROR if at least two arguments are not supplied. An exception of type INVALID-ARGUMENT is thrown if the first argument is not a symbol or if the second argument is not a function object",
   "examples" : [ "(defun f (a b c) (+ a b c)) => <function>", "(def-curry-fn c f 10 20) => <function>", "(c 30) => 60"],
   "see-also" : [  ]
  },

  {"type" : 1, 
   "name" : "dolist", 
   "syntax" : "(dolist spec &rest body) => result",
   "args" : "spec: a list; body: the rest of the arguments converted into a list; result: an object",
   "desc" : "dolist evaluates the code in 'body' for each element in the list specified in the CDR of 'spec', with the value of the element bound to the symbol specified in the CAR of 'spec'. It returns the result of the last evaluation of 'body'",
   "exceptions" : "Throws an exception of type COMPILE-ERROR if the required number of parameters is not supplied. Propagates exceptions thrown (if any) by the underlying macro expansion.",
   "examples" : [ "(dolist (x '(1 2 3)) (print x)) =>", "1", "2", "3", "NIL" ],
   "see-also" : [  ]
  },

  {"type" : 1, 
   "name" : "dotimes", 
   "syntax" : "(dotimes spec &rest body) => result",
   "args" : "spec: a list; body: the rest of the arguments converted into a list; result: an object",
   "desc" : "dotimes initializes the variable specified in the CAR of 'spec' to zero, and evaluates 'body' with the variable bound to this value. It then successively increments the variable and evaluates 'body' till the value of the variable exceeds the value specified in the CDR of 'spec'. It returns the value of the last evaluation of 'body'",
   "exceptions" : "Throws an exception of type COMPILE-ERROR if the required number of parameters is not supplied. Propagates exceptions thrown (if any) by the underlying macro expansion.",
   "examples" : [ "(dotimes (x 3) (print x)) =>", "0", "1", "2", "NIL" ],
   "see-also" : [  ]
  },

  {"type" : 2, 
   "name" : "env", 
   "syntax" : "(env) => result",
   "args" : "result: an object",
   "desc" : "env returns a list of all the top-level bindings",
   "exceptions" : "Throws an exception of type COMPILE-ERROR if any arguments are supplied",
   "examples" : [ "" ],
   "see-also" : [ "" ]
  },

  {"type" : 2, 
   "name" : "eq", 
   "syntax" : "(eq form1 form2) => result",
   "args" : "form1, form2: forms; result: T or NIL",
   "desc" : "eq returns T if 'form1' and 'form2' are structurally equivalent and NIL otherwise",
   "exceptions" : "Throws an exception of type COMPILE-ERROR if the required number of parameters is not supplied",
   "examples" : [ "(eq 1 1) => T", "(eq '(1 2) '(1 2)) => T", "(define x \"abc\") => \"abc\"", "(eq x \"abc\") => T", "(eq 1 'a) => NIL" ],
   "see-also" : [ "array-eq" ]
  },

  {"type" : 2, 
   "name" : "error", 
   "syntax" : "(error str) => result",
   "args" : "str: form that evaluates to a string; result: NIL",
   "desc" : "error creates and throws an exception of type EXCEPTION using 'str'",
   "exceptions" : "Throws exception of type EXCEPTION as described above",
   "examples" : [ "(error \"Divide by zero\") => -" ],
   "see-also" : [ "throw" ]
  },

  {"type" : 2, 
   "name" : "eval", 
   "syntax" : "(eval form) => result",
   "args" : "form: a form; result: an object",
   "desc" : "eval compiles and evaluates the form 'form'",
   "exceptions" : "Propagates exceptions thrown (if any) by the compilation and evaluation of the form",
   "examples" : [ "(eval '(+ 1 1)) => 2" ],
   "see-also" : [  ]
  },

  {"type" : 0, 
   "name" : "exception", 
   "syntax" : "(exception sym str) => result",
   "args" : "sym: a symbol; str: a string; result: an exception object",
   "desc" : "exception creates an exception object from the passed symbol and string and returns it",
   "exceptions" : "Throws an exception of type COMPILE-ERROR if the required number of parameters is not supplied",
   "examples" : [ "(exception 'exception \"An exception\") => (EXCEPTION . \"An exception\")" ],
   "see-also" : [ "error" ]
  },

  {"type" : 2, 
   "name" : "expand-macro", 
   "syntax" : "(expand-macro form) => result",
   "args" : "form: a form; result: a form",
   "desc" : "expand-macro expands the macro application represented by 'form' and returns the result of this expansion. Note that the expansion is only at the first level, i.e. if the expanded form contains any macros, they will not be expanded",
   "exceptions" : "Throws an exception of type COMPILE-ERROR if the required number of parameters is not supplied",
   "examples" : [ "(defmacro first (lst) `(car ,lst)) => <macro>", "(expand-macro '(first some-list)) => (CAR SOME-LIST)" ],
   "see-also" : [  ]
  },

  {"type" : 2, 
   "name" : "export-package", 
   "syntax" : "(export-package package-name str) => NIL",
   "args" : "package-name: a form that evaluates to a string; str: a form that evaluates to a string",
   "desc" : "export-package writes the contents of the package 'package-name' to the file specified by 'str'",
   "exceptions" : "Throws an exception of type COMPILE-ERROR if the required number of parameters is not  passed and an exception of type PACKAGE-NOT-FOUND if 'package-name' does not exist",
   "examples" : [ "(export-package \"user\" \"user.lisp\") => NIL" ],
   "see-also" : [ "create-package", "in-package", "import-package" ]
  },

  {"type" : 2, 
   "name" : "import-package", 
   "syntax" : "(import-package package-name) => NIL",
   "args" : "package-name: a form that evaluates to a string",
   "desc" : "import-package makes available the symbols (and their bound values)  of the package 'package-name' to the current package",
   "exceptions" : "Throws an exception of type COMPILE-ERROR if the required number of parameters is not  passed and an exception of type PACKAGE-NOT-FOUND if 'package-name' does not exist. An exception of type EXCEPTION is thrown if a package is attempted to be imported into itself, or if it is attempted to import the CORE package.",
   "examples" : [ "(import-package \"user\") => NIL" ],
   "see-also" : [ "create-package", "in-package", "export-package" ]
  },

  {"type" : 1, 
   "name" : "fifth", 
   "syntax" : "(fifth lst) => result",
   "args" : "lst: a list; result: an object",
   "desc" : "fifth returns the fifth element of 'lst'",
   "exceptions" : "Throws an exception of type COMPILE-ERROR if the required number of parameters is not supplied. An exception of type NOT-A-CONS is thrown if the argument is not a list",
   "examples" : [ "(fifth '(1 2 3 4 5 6)) => 5" ],
   "see-also" : [ "caar", "cadar", "cadddr", "caddr", "cadr", "car", "cdar", "cddr", "cdr", "first", "second", "third", "fourth" ]
  },

  {"type" : 0, 
   "name" : "find", 
   "syntax" : "(find e lst predicate) => result",
   "args" : "e: an object: lst: a list; predicate: a function; result: an object",
   "desc" : "find returns the first element of 'lst' for which 'predicate' returns true when applied to that element and 'e' and NIL if no such element is found",
   "exceptions" : "Throws an exception of type COMPILE-ERROR if the required number of parameters is not supplied. An exception of type EXCEPTION is thrown if the second parameter is not a list and the third parameter not a function object",
   "examples" : [ "(find 3 '(1 2 3) (lambda (x y) (< x y))) => 1" ],
   "see-also" : [ "find-if", "select" ]
  },

  {"type" : 0, 
   "name" : "find-if", 
   "syntax" : "(find-if predicate lst) => result",
   "args" : "predicate: a function; lst: a list; result: an object",
   "desc" : "find-if returns the first element of 'lst' for which 'predicate' returns true and NIL if no such element is found",
   "exceptions" : "Throws an exception of type COMPILE-ERROR if the required number of parameters is not supplied. An exception of type EXCEPTION is thrown if the first parameter not a function object and the second parameter is not a list",
   "examples" : [ "(find-if (lambda (x) (stringp x)) '(1 \"abc\" 'X)) => \"abc\"" ],
   "see-also" : [ "find", "select" ]
  },

  {"type" : 1, 
   "name" : "first", 
   "syntax" : "(first lst) => result",
   "args" : "lst: a list; result: an object",
   "desc" : "first returns the first element of a list",
   "exceptions" : "Throws an exception of type COMPILE-ERROR if no parameters are supplied. An exception of type NOT-A-CONS is thrown if 'lst' is not a list",
   "examples" : [ "(first '(1 2 3)) => 1", "(first ()) => NIL" ],
   "see-also" : [ "caar", "cadar", "cadddr", "caddr", "cadr", "car", "cdar", "cddr", "cdr", "second", "third", "fourth", "fifth" ]
  },

  {"type" : 0, 
   "name" : "flatten", 
   "syntax" : "(flatten lst) => result",
   "args" : "lst: a list; result: a list",
   "desc" : "flatten converts the sublists of 'lst' into individual elements",
   "exceptions" : "Throws an exception of type COMPILE-ERROR if the required number of parameters is not supplied. An exception of type NOT-A-CONS is thrown if 'lst' is not a list",
   "examples" : [ "(flatten '((1 2 3) (4 5 6))) => (1 2 3 4 5 6)" ],
   "see-also" : [  ]
  },

  {"type" : 2, 
   "name" : "floatp", 
   "syntax" : "(floatp form) => result",
   "args" : "form: an object; result: T or NIL",
   "desc" : "floatp returns T if 'form' evaluates to a float and NIL otherwise",
   "exceptions" : "Throws an exception of type COMPILE-ERROR if no arguments are supplied",
   "examples" : [ "(floatp 3.14) => T", "(floatp #\\a) => NIL" ],
   "see-also" : [ "integerp", "numberp" ]
  },

  {"type" : 1, 
   "name" : "for", 
   "syntax" : "(for (var init-form cond step-form ret-form) &rest body ) => result",
   "args" : "var: symbol; init-form, cond, step-form, ret-form: forms; body: rest of the arguments; result: an object",
   "desc" : "for loops through the execution of 'body', binding 'var' to the value of 'init-form' and updating its value by evaluating 'step-form'. After every execution of 'body', 'cond' is checked, and execution stops if 'cond' evaluates to NIL. Finally 'ret-form' is evaluated and returned",
   "exceptions" : "Throws an exception of type COMPILE-ERROR if the required number of parameters is not supplied. Propagates exceptions thrown (if any) by the underlying macro expansion",
   "examples" : [ "(for (i 0 (< i 3) (incf i) nil) (print i)) =>", "0", "1", "2", "NIL" ],
   "see-also" : [ "dotimes" ]
  },

  {"type" : 2, 
   "name" : "format", 
   "syntax" : "(format fd str &rest args) => NIL",
   "args" : "fd: an integer; str: a form that evaluates to a string; args: rest of the arguments in list form",
   "desc" : "format sends the formatted output specified by the format string 'str' and the arguments to the file specified by the file descriptor 'fd' or to standard output if 'fd' is NIL. The format string is modeled identically to the C format string used in printf and fprintf statements",
   "exceptions" : "Throws an exception of type COMPILE-ERROR if two arguments are not supplied. Throws an exception of type INVALID-ARGUMENT if a) the first argument is neither an integer nor NIL, b) if the second argument is not a string or c) args contains any objects other than integers, floats, characters or strings",
   "examples" : [ "(define x 100) => 100", "(format nil \"%d\" x) =>", "100NIL" ],
   "see-also" : [  ]
  },

  {"type" : 1, 
   "name" : "fourth", 
   "syntax" : "(fourth lst) => result",
   "args" : "lst: a list; result: an object",
   "desc" : "fourth returns the fourth element of 'lst'",
   "exceptions" : "Throws an exception of type COMPILE-ERROR if the required number of parameters is not supplied. An exception of type NOT-A-CONS is thrown if 'lst' is not a list",
   "examples" : [ "(fourth '(1 2 3 4 5 6)) => 4" ],
   "see-also" : [ "caar", "cadar", "cadddr", "caddr", "cadr", "car", "cdar", "cddr", "cdr", "first", "second", "third", "fifth" ]
  },

  {"type" : 0, 
   "name" : "funcall", 
   "syntax" : "(funcall function &rest args) => result",
   "args" : "function: a form that evaluates to a function or a continuation, args: the rest of the arguments converted into a list; result: an object",
   "desc" : "funcall applies the function 'fn' to 'args'",
   "exceptions" : "Throws an exception of type COMPILE-ERROR if the required number of parameters is not supplied. An exception of type INVALID-ARGUMENT is thrown if the first parameter is not a function object",
   "examples" : [ "(funcall (lambda (x y) (+ x y)) 1 2) => 3" ],
   "see-also" : [ "apply" ]
  },

  {"type" : 2, 
   "name" : "gensym", 
   "syntax" : "(gensym) => result",
   "args" : "result: a symbol",
   "desc" : "gensym creates a new symbol that is guaranteed to be unique",
   "exceptions" : "None",
   "examples" : [ "(gensym) => #:G00027194" ],
   "see-also" : [  ]
  },

  {"type" : 2, 
   "name" : "if", 
   "syntax" : "(if cond then else) => result",
   "args" : "cond, then, else: forms; result: an object",
   "desc" : "if evaluates 'cond', and if 'cond' evaluates to a non-NIL value, evaluates 'then', otherwise evaluates 'else'",
   "exceptions" : "Throws an exception of type COMPILE-ERROR if at least the condition and 'then' parameters are not supplied. Propagates any exception thrown during the evaluation of the 'then' or 'else' forms",
   "examples" : [ "(if (> 2 1) 'true 'false) => TRUE" ],
   "see-also" : [ "cond" ]
  },

  {"type" : 2, 
   "name" : "in-package", 
   "syntax" : "(in-package package-name) => NIL",
   "args" : "package-name: a form that evaluates to a string",
   "desc" : "in-package sets the current package to 'package-name'",
   "exceptions" : "Throws an exception of type COMPILE-ERROR if no parameters are passed. Throws an exception of type ACCESS-VIOLATION if applied to the CORE package. Throws an exception of type PACKAGE-NOT-FOUND if 'package-name' does not exist.",
   "examples" : [ "(in-package \"some-package\") => NIL" ],
   "see-also" : [ "create-package", "export-package", "import-package" ]
  },

  {"type" : 1, 
   "name" : "incf", 
   "syntax" : "(incf var) => result",
   "args" : "var: symbol; result: an integer or float",
   "desc" : "incf increments 'var' by one",
   "exceptions" : "Throws an exception of type COMPILE-ERROR if no parameters are passed. Throws an exception INVALID-ARGUMENT if 'var' is not a symbol or if it is not bound to an integer or a float",
   "examples" : [ "(define x 0) => 0", "(incf x) => 1", "X => 1" ],
   "see-also" : [  ]
  },

  {"type" : 2, 
   "name" : "integerp", 
   "syntax" : "(integerp form) => result",
   "args" : "form: an object; result: T or NIL",
   "desc" : "integerp returns T if 'form' evaluates to an integer and NIL otherwise",
   "exceptions" : "Throws an exception of type COMPILE-ERROR if no arguments are supplied",
   "examples" : [ "(integerp 3) => T", "(integerp #\\a) => NIL" ],
   "see-also" : [ "floatp", "numberp" ]
  },

  {"type" : 2, 
   "name" : "lambda", 
   "syntax" : "(lambda params &rest body) => result",
   "args" : "params: a list; body: the rest of the arguments converted into a list; result: a function object",
   "desc" : "lambda creates a function object with params 'params' and body 'body'",
   "exceptions" : "Throws an exception of type COMPILE-ERROR if exactly two arguments are not supplied or if the first argument is not a list",
   "examples" : [ "(lambda (n) (* n 2)) => <function>" ],
   "see-also" : [ "defun" ]
  },

  {"type" : 0, 
   "name" : "last", 
   "syntax" : "(last lst) => result",
   "args" : "lst: a list; result: an object",
   "desc" : "last returns the last element of 'lst'",
   "exceptions" : "Throws an exception of type COMPILE-ERROR if no parameters are supplied. An exception of type NOT-A-CONS is thrown if 'lst' is not a list",
   "examples" : [ "(last '(1 2 3)) => 3", "(last '()) => NIL" ],
   "see-also" : [ "butlast", "last-n" ]
  },

  {"type" : 0, 
   "name" : "last-n", 
   "syntax" : "(last-n lst n) => result",
   "args" : "lst: a list; n: an integer; result: a list",
   "desc" : "last-n returns the last 'n' elements of 'lst'",
   "exceptions" : "Throws an exception of type COMPILE-ERROR if the required numbers of parameters is not passed. Throws an exception of type EXCEPTION if 'lst' is not a list and an exception of type INVALID-ARGUMENT if 'n' is not an integer",
   "examples" : [ "(last-n '(1 2 3) 2) => (2 3)" ],
   "see-also" : [ "butlast", "last" ]
  },

  {"type" : 0, 
   "name" : "length", 
   "syntax" : "(length lst) => result",
   "args" : "lst: a list; result: an integer",
   "desc" : "length returns the number of elements in 'lst'",
   "exceptions" : "Throws an exception of type COMPILE-ERROR if no arguments are passed, and an exception of type EXCEPTION if 'lst' is not a list",
   "examples" : [ "(length '(1 2 3 4 5)) => 5", "(length '()) => 0" ],
   "see-also" : [ "array-length" ]
  },

  {"type" : 2, 
   "name" : "let", 
   "syntax" : "(let decls &rest body) => result",
   "args" : "decls: a form; body: rest of the arguments converted into a list; result: an object",
   "desc" : "let executes 'body' after binding the definitions in 'decl'",
   "exceptions" : "Throws an exception of type COMPILER-ERROR if the required number of parameters are not supplied or if the first parameter is not a list of (symbol value) bindings",
   "examples" : [ "(let ((x 10) (y 20)) (+ x y)) => 30" ],
   "see-also" : [ "letrec", "let*" ]
  },

  {"type" : 1, 
   "name" : "let*", 
   "syntax" : "(let* decls &rest body) => result",
   "args" : "decls: a form; body: rest of the arguments converted into a list; result: an object",
   "desc" : "let* executes 'body' after binding the definitions in 'decl'. let* is similar to let, but variables in 'decl' can refer to variables declared earlier",
   "exceptions" : "Throws an exception of type COMPILER-ERROR if the required number of parameters are not supplied or if the first parameter is not a list of (symbol value) bindings",
   "examples" : [ "(let* ((x 10) (y (+ x 10))) (+ x y)) => 30" ],
   "see-also" : [ "let", "letrec" ]
  },

  {"type" : 2, 
   "name" : "letrec", 
   "syntax" : "(letrec decls &rest body) => result",
   "args" : "decls: a form; body: rest of the arguments converted into a list; result: an object",
   "desc" : "letrec executes 'body' after binding the definitions in 'decl'; it differs from 'let' in that the bindings can be (mutually) recursive",
   "exceptions" : "Throws an exception of type COMPILER-ERROR if the required number of parameters are not supplied or if the first parameter is not a list of (symbol value) bindings",
   "examples" : [ "(letrec ((fact (lambda (n) (if (eq n 0) 1 (* n (fact (- n 1))))))) (fact 10.0)) => 3628800" ],
   "see-also" : [ "let", "let*" ]
  },

  {"type" : 2, 
   "name" : "list", 
   "syntax" : "(list &rest elems) => result",
   "args" : "elems: arguments converted into a list; result: a list",
   "desc" : "list creates a list of the elements in 'elems'",
   "exceptions" : "None",
   "examples" : [ "(list 'a 'b 'c) => (A B C)" ],
   "see-also" : [ "cons" ]
  },

  {"type" : 2, 
   "name" : "listp", 
   "syntax" : "(listp form) => result",
   "args" : "form: an object; result: T or NIL",
   "desc" : "listp returns T if 'form' evaluates to a list and NIL otherwise",
   "exceptions" : "Throws an exception of type COMPILE-ERROR if no arguments are supplied",
   "examples" : [ "(listp '(1 2 3)) => T", "(listp '()) => T", "(listp 'a) => NIL" ],
   "see-also" : [  ]
  },

  {"type" : 2, 
   "name" : "load-file", 
   "syntax" : "(load-file str) => NIL",
   "args" : "str: a form that evaluates to a string",
   "desc" : "load-file loads the file named 'str' and evaluates the expressions defined in the file",
   "exceptions" : "Throws an exception of type COMPILE-ERROR if no arguments are supplied. Throws an exception of type INVALID-ARGUMENT if the argument is not a string. Exceptions of type FILE-OPEN-ERROR and FILE-READ-ERROR are thrown if the file cannot be opened or read respectively",
   "examples" : [ "(load-file \"1.lisp\") => NIL" ],
   "see-also" : [  ]
  },

  {"type" : 2, 
   "name" : "load-foreign-library", 
   "syntax" : "(load-foreign-library str) => NIL",
   "args" : "str: a form that evaluates to a string",
   "desc" : "load-foreign-library loads the shared library file named 'str'",
   "exceptions" : "Throws an exception of type COMPILE-ERROR if no arguments are supplied. Throws an exception of type INVALID-ARGUMENT if the argument is not a string. An exception of type EXCEPTION is thrown if the maximum number of foreign libraries that can be loaded is exceeded. An OUT-OF-MEMORY exception is thrown if there is no memory to allocate for the structures internally needed to load the foreign library. An exception of type EXCEPTION is thrown if the shared library is an invalid file",
   "examples" : [ "(load-foreign-library \"somelib.so\") => NIL" ],
   "see-also" : [ "call-foreign-function" ]
  },

  {"type" : 2, 
   "name" : "load-object", 
   "syntax" : "(load-object str) => result",
   "args" : "str: a form that evaluates to a string; result: an object",
   "desc" : "load-object loads the object serialized in the file named 'str'",
   "exceptions" : "Throws an exception of type COMPILE-ERROR if no arguments are supplied. Throws an exception of type INVALID-ARGUMENT if the argument is not a string. An exception of type EXCEPTION is thrown if the file is not a valid file (created using save-object)",
   "examples" : [ "(load-object \"object.lisp\") => <an object>" ],
   "see-also" : [ "save-object" ]
  },

  {"type" : 2, 
   "name" : "macro", 
   "syntax" : "(macro params &rest body) => result",
   "args" : "params: a list; body: the rest of the arguments converted into a list; result: a macro object",
   "desc" : "macro creates a macro object with params 'params' and body 'body'",
   "exceptions" : "Throws an exception of type COMPILE-ERROR if exactly two arguments are not supplied or if the first argument is not a list",
   "examples" : [ "(macro (x) `(car ,x)) => <macro>" ],
   "see-also" : [ "defmacro" ]
  },

  {"type" : 2, 
   "name" : "macrop", 
   "syntax" : "(macrop form) => result",
   "args" : "form: an object; result: T or NIL",
   "desc" : "macrop returns T if 'form' evaluates to a macro object and NIL otherwise",
   "exceptions" : "Throws an exception of type COMPILE-ERROR if no arguments are supplied",
   "examples" : [ "(macrop defun) => T", "(macrop 10) => NIL" ],
   "see-also" : [  ]
  },

  {"type" : 2, 
   "name" : "make-array", 
   "syntax" : "(make-array size val) => result",
   "args" : "size: an integer; val: an object; result: an array object",
   "desc" : "make-array creates an array of size 'size'  with all the array elements initialized to 'val'",
   "exceptions" : "Throws an exception of type COMPILE-ERROR if no arguments are supplied. Throws an exception of type INVALID-ARGUMENT if the first argument is not an integer",
   "examples" : [ "(make-array 5 1) => [1 1 1 1 1]", "(make-array 3 nil) => [NIL NIL NIL]" ],
   "see-also" : [ "make-string" ]
  },

  {"type" : 1, 
   "name" : "make-string", 
   "syntax" : "(make-string size val) => result",
   "args" : "size: an integer; val: a character; result: a string object",
   "desc" : "make-string creates a string of length 'size', with all the string positions initialized to 'val'",
   "exceptions" : "Throws an exception of type COMPILE-ERROR if no arguments are supplied. Throws an exception of type INVALID-ARGUMENT if the first argument is not an integer",
   "examples" : [ "(make-string 5 #\\a) => \"aaaaa\"" ],
   "see-also" : [ "make-array" ]
  },

  {"type" : 1, 
   "name" : "map", 
   "syntax" : "(map fn lst) => result",
   "args" : "fn: a function object; lst: a list; result: a list",
   "desc" : "map applies the function 'fn' to each element in 'lst' and returns a newly-constructed list comprising the result of the function applications",
   "exceptions" : "Throws an exception of type COMPILE-ERROR if the required number of arguments is not supplied. Throws an exception of type NOT-A-CONS if 'lst' is not a list. An exception of type EXCEPTION is thrown if 'fn' is not a function object",
   "examples" : [ "(map (lambda (x) (* 2 x)) '(1 2 3 4 5)) => (2 4 6 8 10)" ],
   "see-also" : [ "mapcan", "mapcar" ]
  },

  {"type" : 1, 
   "name" : "mapcan", 
   "syntax" : "(mapcan fn &rest lsts) => result",
   "args" : "fn: a function object; lsts: the rest of the arguments converted into a list",
   "desc" : "For i ranging from zero to 'min', where 'min' is the minimum of the lengths of the lists 'lsts', mapcan takes the ith element of each of the lists in 'lsts' and applies 'fn' to the list of arguments thus formed. It collects the results of these function applications in a list and returns the flattened list",
   "exceptions" : "Throws an exception of type COMPILE-ERROR if the required number of arguments is not supplied. Throws an exception of type NOT-A-CONS if 'lst' is not a list. An exception of type INVALID-ARGUMENT is thrown if 'fn' is not a function object",
   "examples" : [ "(mapcan (lambda (x y) (list x y)) '(1 2) '(3 4)) => (1 3 2 4)" ],
   "see-also" : [ "map", "mapcar" ]
  },

  {"type" : 0, 
   "name" : "mapcar", 
   "syntax" : "(mapcar fn &rest lsts) => result",
   "args" : "fn: a function object; lsts: the rest of the arguments converted into a list",
   "desc" : "For i ranging from zero to 'min', where 'min' is the minimum of the lengths of the lists lsts, mapcan takes the ith element of each of the lists in 'lsts' and applies 'fn' to the list of arguments thus formed. It collects the results of these function applications in a list and returns this list.",
   "exceptions" : "Throws an exception of type COMPILE-ERROR if the required number of arguments is not supplied. Throws an exception of type NOT-A-CONS if 'lst' is not a list. An exception of type INVALID-ARGUMENT is thrown if 'fn' is not a function object",
   "examples" : [ "(mapcar (lambda (x y) (list x y)) '(1 2) '(3 4)) => ((1 3) (2 4))" ],
   "see-also" : [ "map", "mapcan" ]
  },

  {"type" : 0, 
   "name" : "max", 
   "syntax" : "(max lst) => result",
   "args" : "lst: a list; result: an object",
   "desc" : "max returns the largest element in 'lst'",
   "exceptions" : "Throws an exception of type COMPILE-ERROR if no arguments are supplied. An exception of type NOT-A-CONS is thrown if 'lst' is not a list",
   "examples" : [ "(max '(2 3 7 8 10 9)) => 10" ],
   "see-also" : [ "min" ]
  },

  {"type" : 0, 
   "name" : "min", 
   "syntax" : "(min lst) => result",
   "args" : "lst: a list; result: an object",
   "desc" : "min returns the smallest element in 'lst'",
   "exceptions" : "Throws an exception of type COMPILE-ERROR if no arguments are supplied. An exception of type NOT-A-CONS is thrown if 'lst' is not a list",
   "examples" : [ "(min '(2 3 7 8 10 9)) => 2" ],
   "see-also" : [ "max" ]
  },

  {"type" : 1, 
   "name" : "multiple-value-bind", 
   "syntax" : "(multiple-value-bind vars var-form &rest body) => result",
   "args" : "vars: a list of symbols; var-form: a list; body: the rest of the arguments converted into a list; result: an object",
   "desc" : "multiple-value-bind binds 'vars' to the values specified in 'var-form' and evaluates the expressions in 'body'",
   "exceptions" : "Throws an exception of type COMPILE-ERROR if the required number of arguments is not supplied or if the first parameter is not a list of symbols. An exception of type INVALID-ARGUMENT is thrown if the second parameter is not a list. An exception of type EXCEPTION is thrown if there is a mismatch/inconsistency in the number/binding of variables among 'vars', 'var-form' and 'body'.",
   "examples" : [ "(multiple-value-bind (x y) '(3 4) (+ x y)) => 7" ],
   "see-also" : [ "values" ]
  },

  {"type" : 1, 
   "name" : "nconc", 
   "syntax" : "(nconc sym &rest lsts) => result",
   "args" : "sym: a symbol; lsts: the rest of the arguments (which are themselves lists) converted into a list; result: a list",
   "desc" : "nconc appends 'lsts' to the list object bound to the symbol 'sym'",
   "exceptions" : "Throws an exception of type COMPILE-ERROR if no arguments are supplied. An exception of type EXCEPTION is thrown if 'sym' is undefined. An exception of type INVALID-ARGUMENT is thrown if 'sym' is not bound to a list object or if any of the elements of 'lsts' is not a list",
   "examples" : [ "(define x '(1 2 3)) => (1 2 3)", "x => (1 2 3)", "(nconc x '(4 5 6) '(7 8 9)) => (1 2 3 4 5 6 7 8 9)", "x => (1 2 3 4 5 6 7 8 9)" ],
   "see-also" : [ "append", "concat" ]
  },

  {"type" : 1, 
   "name" : "neq", 
   "syntax" : "(neq form1 form2) => result",
   "args" : "form1, form2: forms; result: T or NIL",
   "desc" : "neq returns T if 'form1' and 'form2' are not structurally equivalent and NIL otherwise",
   "exceptions" : "Throws en exception of type COMPILE-ERROR if two arguments are not supplied",
   "examples" : [ "(neq 1 1) => NIL", "(neq '(1 2) '(1 2)) => NIL", "(define x \"abc\") => \"abc\"", "(neq x \"abc\") => NIL", "(neq 1 'a) => T" ],
   "see-also" : [ "eq" ]
  },

  {"type" : 2, 
   "name" : "newline", 
   "syntax" : "(newline fd) => NIL",
   "args" : "fd: an integer or NIL",
   "desc" : "newline prints a newline to the file specified by the file descriptor 'fd' if 'fd' is not NIL, and to the Transcript window or the shell if 'fd' is NIL",
   "exceptions" : "Throws an exception of type COMPILE-ERROR if no arguments are supplied. An exception of type INVALID-ARGUMENT is thrown if 'fd' is not a valid file descriptor",
   "examples" : [  ],
   "see-also" : [ "println" ]
  },

  {"type" : 2, 
   "name" : "not", 
   "syntax" : "(not form) => result",
   "args" : "form: a form; result: T or NIL",
   "desc" : "not returns T if 'form' evaluates to NIL and NIL otherwise",
   "exceptions" : "Throws an exception of type COMPILE-ERROR if no arguments are supplied",
   "examples" : [ "(not (eq 1 1)) => NIL", "(not (eq 1 #\\a)) => T" ],
   "see-also" : [ "null" ]
  },

  {"type" : 0, 
   "name" : "nth", 
   "syntax" : "(nth lst n) => result",
   "args" : "lst: a list; n: an integer; result: an object",
   "desc" : "nth returns the nth element in 'lst'. Note that list indices start from zero",
   "exceptions" : "Throws an exception of type COMPILE-ERROR if the required number of arguments is not supplied. An exception of type EXCEPTION is thrown if 'lst' is not a list. Throws an exception of type INVALID-ARGUMENT if 'n' is not an integer",
   "examples" : [ "(nth 3 '(2 3 7 8 10 9)) => 8" ],
   "see-also" : [ "first", "second", "third", "fourth", "fifth" ]
  },

  {"type" : 0, 
   "name" : "null", 
   "syntax" : "(null form) => result",
   "args" : "form: an object; result: T or NIL",
   "desc" : "null returns T if 'form' evaluates to NIL and NIL otherwise",
   "exceptions" : "Throws an exception of type COMPILE-ERROR if no arguments are supplied.",
   "examples" : [ "(null 1) => NIL", "(null '()) => T" ],
   "see-also" : [ "not" ]
  },

  {"type" : 0, 
   "name" : "numberp", 
   "syntax" : "(numberp form) => result",
   "args" : "form: an object; result: T or NIL",
   "desc" : "numberp returns T if 'form' evaluates to an integer or a float and NIL otherwise",
   "exceptions" : "Throws an exception of type COMPILE-ERROR if no arguments are supplied.",
   "examples" : [ "(numberp 1) => T", "(numberp 3.14) => T", "(numberp 'a) => NIL" ],
   "see-also" : [ "integerp", "floatp" ]
  },

  {"type" : 1, 
   "name" : "or", 
   "syntax" : "(or form*) => result",
   "args" : "form: an object; result: T or NIL",
   "desc" : "or performs a logical disjunction of its operands. Returns T if any of the operands evaluates to non-NIL and NIL otherwise. Returns T if no arguments are passed",
   "exceptions" : "None",
   "examples" : [ "(or (eq 1 1) (eq 2 3)) => T", "(or (eq 2 3) (eq 1 2)) => NIL" ],
   "see-also" : [ "and" ]
  },

  {"type" : 0, 
   "name" : "pair", 
   "syntax" : "(pair lst1 lst2) => result",
   "args" : "lst1, lst2: lists; result: a list",
   "desc" : "pair creates pairs by forming a list from objects in 'lst1' and 'lst2' that share the same ordinal position. If the lengths of 'lst1' and 'lst2' are not the same, the lists are created by substituting with NILs",
   "exceptions" : "Throws an exception of type COMPILE-ERROR if the required number of parameters is not supplied. An exception of type NOT-A-CONS is thrown if either of the arguments is neither a list nor NIL",
   "examples" : [ "(pair '(1 2 3) '(4 5 6 7)) => ((1 4) (2 5) (3 6) (NIL 7))" ],
   "see-also" : [ "cons-pair" ]
  },

  {"type" : 2, 
   "name" : "print", 
   "syntax" : "(print obj) => NIL",
   "args" : "obj: an object",
   "desc" : "print prints the object 'obj' to the shell if pLisp is invoked with '-c' and to the Transcript if otherwise",
   "exceptions" : "Throws an exception of type COMPILE-ERROR if no arguments are supplied",
   "examples" : [ "(print \"Hello world\") =>", "\"Hello world\"", "\"Hello world\"", "(print (make-array 5 nil)) =>", "[NIL NIL NIL NIL NIL]", "[NIL NIL NIL NIL NIL]" ],
   "see-also" : [ "print-string" ]
  },

  {"type" : 2, 
   "name" : "print-string", 
   "syntax" : "(print-string str) => NIL",
   "args" : "str: a form that evaluates to a string object",
   "desc" : "print-string prints the string object 'str' to the shell if pLisp is invoked with '-c' and to the Transcript if otherwise",
   "exceptions" : "Throws an exception of type COMPILE-ERROR if no arguments are supplied, and an exception of type INVALID-ARGUMENT if 'str' is not a string",
   "examples" : [ "(print-string \"Hello world\") =>", "\"Hello world\"NIL", "(define x \"abc\") => \"abc\"", "(print-string x) =>", "\"abc\"NIL" ],
   "see-also" : [ "print" ]
  },

  {"type" : 1, 
   "name" : "println", 
   "syntax" : "(println) => NIL",
   "args" : "None",
   "desc" : "println prints a newline to the shell",
   "exceptions" : "None",
   "examples" : [  ],
   "see-also" : [ "newline" ]
  },

  {"type" : 2, 
   "name" : "profile", 
   "syntax" : "(profile exp) => NIL",
   "args" : "exp: a quoted form",
   "desc" : "profile evaluates 'exp' and displays the resource usage information for the evaluation",
   "exceptions" : "Propagates exceptions thrown (if any) by the evaluation of the form",
   "examples" : [ "(profile '(+ 1 1)) =>", "Expression took 0.017554 seconds (elapsed), 0.013966 seconds (CPU), 2696 words allocated", "2" ],
   "see-also" : [ "time" ]
  },

  {"type" : 1, 
   "name" : "progn", 
   "syntax" : "(progn form*) => result",
   "args" : "form: a form; result: an object",
   "desc" : "progn evaluates each of the forms supplied to it as arguments and returns the result of the evaluation of the last form",
   "exceptions" : "Propagates exceptions thrown (if any) by the evaluation of any of the forms",
   "examples" : [ "(progn (print \"hello\") (+ 1 1)) =>", "\"hello\"", "2" ],
   "see-also" : [  ]
  },

  {"type" : 0, 
   "name" : "range", 
   "syntax" : "(range start end inc) => result",
   "args" : "start, end, inc: integers or floats; result: a list",
   "desc" : "range creates a list with 'start' as the first element and 'end' as the last element, with the middle elements obtained by successively incrementing 'start' with 'inc'",
   "exceptions" : "Throws an exception of type COMPILE-ERROR if the required number of arguments is not supplied. An exception of type INVALID-EXCEPTION is thrown if any of the arguments is neither an integer nor a float",
   "examples" : [ "(range 1 10 1) => (1 2 3 4 5 6 7 8 9 10)" ],
   "see-also" : [  ]
  },

  {"type" : 0, 
   "name" : "read", 
   "syntax" : "(read) => result",
   "args" : "result: an integer, float or string object",
   "desc" : "read reads a value from the standard input and returns an integer, float or string object after suitably converting the value",
   "exceptions" : "Throws an exception of type COMPILE-ERROR if any arguments are supplied, and an exception of type EXCEPTION if the read was unsuccessful",
   "examples" : [  ],
   "see-also" : [ "read-character", "read-float", "read-integer", "read-string" ]
  },

  {"type" : 0, 
   "name" : "read-character", 
   "syntax" : "(read-character) => result",
   "args" : "result: a character object",
   "desc" : "read-character reads a character from the standard input",
   "exceptions" : "Throws an exception of type COMPILE-ERROR if any arguments are supplied, and an exception of type NOT-A-STRING if an integer or a float is entered",
   "examples" : [  ],
   "see-also" : [ "read", "read-float", "read-integer", "read-string" ]
  },

  {"type" : 0, 
   "name" : "read-float", 
   "syntax" : "(read-float) => result",
   "args" : "result: a float object",
   "desc" : "read-float reads a float from the standard input",
   "exceptions" : "Throws an exception of type COMPILE-ERROR if any arguments are supplied, and an exception of type NOT-A-FLOAT if a character or string is entered",
   "examples" : [  ],
   "see-also" : [ "read", "read-character", "read-integer", "read-string" ]
  },

  {"type" : 0, 
   "name" : "read-integer", 
   "syntax" : "(read-integer) => result",
   "args" : "result: an integer object",
   "desc" : "read-integer reads an integer from the standard input",
   "exceptions" : "Throws an exception of type COMPILE-ERROR if any arguments are supplied, and an exception of type NOT-AN-INTEGER if a character or string is entered",
   "examples" : [  ],
   "see-also" : [ "read", "read-character", "read-float", "read-string" ]
  },

  {"type" : 0, 
   "name" : "read-string", 
   "syntax" : "(read-string) => result",
   "args" : "result: a string object",
   "desc" : "read-string reads a string from the standard input",
   "exceptions" : "Throws an exception of type COMPILE-ERROR if any arguments are supplied, and an exception of type NOT-A-STRING if an integer or a float is entered",
   "examples" : [  ],
   "see-also" : [ "read", "read-character", "read-float", "read-integer" ]
  },

  {"type" : 0, 
   "name" : "remove", 
   "syntax" : "(remove e lst n) => result",
   "args" : "e: an object; lst: a list; result: a list",
   "desc" : "remove removes the first 'n' occurrences of 'e' from 'lst'",
   "exceptions" : "Throws an exception of type COMPILE-ERROR if the required number of arguments is not supplied. An exception of type NOT-A-CONS is thrown if 'lst' is not a list",
   "examples" : [ "(remove 1 '(1 1 2 1 3 4) 2) => (2 1 3 4)" ],
   "see-also" : [ "remove-duplicates", "remove-if", "remove-if-not", "remove-last" ]
  },

  {"type" : 1, 
   "name" : "remove-duplicates", 
   "syntax" : "(remove-duplicates lst test) => result",
   "args" : "lst: a list; test: a function object; result: a list",
   "desc" : "remove-duplicates removes duplicates from 'lst', using 'test' to test for equality",
   "exceptions" : "Throws an exception of type COMPILE-ERROR if the required number of arguments is not supplied. An exception of type NOT-A-CONS is thrown if 'lst' is not a list. An exception of type EXCEPTION is thrown if 'test' is not a function",
   "examples" : [ "(remove-duplicates '(1 1 2 1 3 4) (lambda (x y) (eq x y))) => (1 2 3 4)" ],
   "see-also" : [ "remove", "remove-if", "remove-if-not", "remove-last" ]
  },

  {"type" : 0, 
   "name" : "remove-if", 
   "syntax" : "(remove-if pred lst) => result",
   "args" : "pred: a function object; lst: a list; result: a list",
   "desc" : "remove-if removes those elements in 'lst' for which 'pred' returns a non-NIL value",
   "exceptions" : "Throws an exception of type COMPILE-ERROR if the required number of arguments is not supplied. An exception of type NOT-A-CONS is thrown if 'lst' is not a list. An exception of type EXCEPTION is thrown if 'pred' is not a function",
   "examples" : [ "(remove-if (lambda (x) (>= x 3)) '(1 1 2 1 3 4)) => (1 1 2 1)" ],
   "see-also" : [ "remove", "remove-duplicates", "remove-if-not", "remove-last" ]
  },

  {"type" : 1, 
   "name" : "remove-if-not", 
   "syntax" : "(remove-if-not pred lst) => result",
   "args" : "pred: a function; lst: a list; result: a list",
   "desc" : "remove-if-not removes those elements in 'lst' for which 'pred' returns NIL",
   "exceptions" : "Throws an exception of type COMPILE-ERROR if the required number of arguments is not supplied. An exception of type NOT-A-CONS is thrown if 'lst' is not a list. An exception of type EXCEPTION is thrown if 'pred' is not a function",
   "examples" : [ "(remove-if-not (lambda (x) (>= x 3)) '(1 1 2 1 3 4)) => (3 4)" ],
   "see-also" : [ "remove", "remove-duplicates", "remove-if", "remove-last" ]
  },

  {"type" : 0, 
   "name" : "remove-last", 
   "syntax" : "(remove-last lst) => result",
   "args" : "lst: a list; result: a list",
   "desc" : "remove-last removes the last element in 'lst'",
   "exceptions" : "Throws an exception of type COMPILE-ERROR if no arguments are supplied. An exception of type EXCEPTION is thrown if 'lst' is not a list",
   "examples" : [ "(remove-last '(1 1 2 1 3 4)) => (1 1 2 1 3)" ],
   "see-also" : [ "remove", "remove-duplicates", "remove-if", "remove-if-not" ]
  },

  {"type" : 1, 
   "name" : "rest", 
   "syntax" : "(rest lst) => result",
   "args" : "lst: a form that evaluates to a list; result: an object",
   "desc" : "rest retuns the list comprising all the elements of 'lst' except the first one",
   "exceptions" : "Throws an exception of type COMPILE-ERROR if no arguments are supplied, and an exception of type NOT-A-CONS if lst is not a list",
   "examples" : [ "(rest '(1 2 3 4)) => (2 3 4)" ],
   "see-also" : [ "cdr" ]
  },

  {"type" : 2, 
   "name" : "resume", 
   "syntax" : "(resume) => NIL",
   "args" : "None",
   "desc" : "resume resumes the evaluation of the expression after a BREAK",
   "exceptions" : "None; an error is raised if abort is invoked when not in debug mode (entered via a 'break')",
   "examples" : [  ],
   "see-also" : [ "abort", "break" ]
  },

  {"type" : 2, 
   "name" : "return-from", 
   "syntax" : "(return-from fn ret) => result",
   "args" : "fn: a function or a macro object; ret: an object; result: an object",
   "desc" : "return-from returns control from the execution of 'fn' to its calling frame with 'fn' returning the value 'ret'",
   "exceptions" : "Throws an exception of type EXCEPTION if the required number of arguments is not supplied, if the first parameter is not a function object or if it is invoked in an invalid context (e.g. from the REPL or the workspace)",
   "examples" : [  ],
   "see-also" : [  ]
  },

  {"type" : 0, 
   "name" : "reverse", 
   "syntax" : "(reverse lst) => result",
   "args" : "lst: a list; result: a list",
   "desc" : "reverse creates a new list that contains the contents of 'lst' in reverse order",
   "exceptions" : "Throws an exception of type COMPILE-ERROR if no arguments are supplied, and an exception of type NOT-A-CONS if 'lst' is not a list",
   "examples" : [ "(reverse '(1 1 2 1 3 4)) => (4 3 1 2 1 1)" ],
   "see-also" : [  ]
  },

  {"type" : 2, 
   "name" : "save-object", 
   "syntax" : "(save-object obj str) => NIL",
   "args" : "obj: an object; str: a form that evaluates to a string",
   "desc" : "save-object serializes the object 'obj' to the file named 'str'. All objects referred to by 'obj' are included in this serialization",
   "exceptions" : "Throws an exception of type COMPILE-ERROR if the required number of arguments is not supplied. Throws an exception of type INVALID-ARGUMENT if the second argument is not a string. An exception of type EXCEPTION is thrown if the file cannot be created",
   "examples" : [ "(save-object some-obj \"object.lisp\") => NIL" ],
   "see-also" : [ "load-object" ]
  },

  {"type" : 1, 
   "name" : "second", 
   "syntax" : "(second lst) => result",
   "args" : "lst: a list; result: an object",
   "desc" : "second returns the second element of a list",
   "exceptions" : "Throws an exception of type COMPILE-ERROR if no arguments are supplied, and an exception of type NOT-A-CONS if 'lst' is not a list",
   "examples" : [ "(second '(1 2 3)) => 2", "(second ()) => NIL" ],
   "see-also" : [ "caar", "cadar", "cadddr", "caddr", "cadr", "car", "cdar", "cddr", "cdr", "first", "third", "fourth", "fifth" ]
  },

  {"type" : 0, 
   "name" : "select", 
   "syntax" : "(select pred lst) => result",
   "args" : "pred: a function; lst: a list; result: a list",
   "desc" : "select builds a new list containing the elements in 'lst' for which 'pred' evaluates to a non-NIL value",
   "exceptions" : "Throws an exception of type COMPILE-ERROR if no arguments are passed. An exception of type NOT-A-CONS is thrown if 'lst' is not a list. Throws an exception of type EXCEPTION if 'pred' is not a function object",
   "examples" : [ "(select (lambda (x) (numberp x)) '(1 2 #\\a \"abc\" 'x)) => (1 2)" ],
   "see-also" : [ "find", "find-if" ]
  },

  {"type" : 2, 
   "name" : "setcar", 
   "syntax" : "(setcar lst obj) => obj",
   "args" : "lst: a list; obj: an object",
   "desc" : "setcar updates the CAR of 'lst' to 'obj'",
   "exceptions" : "Throws an exception of type COMPILE-ERROR if exactly two arguments are not supplied and an exception of type NOT-A-CONS if the first argument is not a list",
   "examples" : [ "(define x '(1 2)) => (1 2)", "x => (1 2)", "(setcar x 100) => 100", "x => (100 2)" ],
   "see-also" : [ "setcdr" ]
  },

  {"type" : 2, 
   "name" : "setcdr", 
   "syntax" : "(setcdr lst obj) => obj",
   "args" : "lst: a list; obj: an object",
   "desc" : "setcar updates the CDR of 'lst' to 'obj'",
   "exceptions" : "Throws an exception of type COMPILE-ERROR if exactly two arguments are not supplied and an exception of type NOT-A-CONS if the first argument is not a list",
   "examples" : [ "(define x '(1 2)) => (1 2)", "x => (1 2)", "(setcdr x 100) => 100", "x => (1 . 100)" ],
   "see-also" : [ "setcar" ]
  },

  {"type" : 2, 
   "name" : "set", 
   "syntax" : "(set var obj) => obj",
   "args" : "var: a symbol; obj: an object",
   "desc" : "set binds 'var' to 'obj'",
   "exceptions" : "Throws an exception of type INVALID-ARGUMENT if the required number of arguments are not supplied or if the first argument is not a symbol. Throws exception EXCEPTION if 'var' has not been defined",
   "examples" : [ "(define x) => NIL", "(set x 100) => 100", "x => 100" ],
   "see-also" : [ "setq" ]
  },

  {"type" : 1, 
   "name" : "setq", 
   "syntax" : "(setq var obj) => obj",
   "args" : "var: a symbol; obj: an object",
   "desc" : "setq binds 'var' to 'obj'; it is identical to 'set' and is defined to provide limited compatibility to Common Lisp",
   "exceptions" : "Throws an exception of type INVALID-ARGUMENT if the required number of arguments are not supplied or if the first argument is not a symbol. Throws exception EXCEPTION if 'var' has not been defined",
   "examples" : [ "(define x) => NIL", "(setq x 100) => 100", "x => 100" ],
   "see-also" : [ "set" ]
  },

  {"type" : 2, 
   "name" : "string", 
   "syntax" : "(string str) => str",
   "args" : "str: a string literal",
   "desc" : "string creates a string object from 'str'",
   "exceptions" : "Throws an exception of type COMPILE-ERROR if no arguments are supplied. An exception of type INVALID-ARGUMENT is thrown if the argument is not a string literal",
   "examples" : [ "(define x) => NIL", "(set x (string \"abc\")) => X", "x => \"abc\"" ],
   "see-also" : [  ]
  },

  {"type" : 1, 
   "name" : "string-get", 
   "syntax" : "(string-get str pos) => result",
   "args" : "str: a form that evaluates to a string; pos: an integer; result: a character",
   "desc" : "string-get returns the character at position 'pos' of 'str'. Note that string indices start at zero",
   "exceptions" : "Throws an exception of type COMPILE-ERROR if no arguments are supplied. Throws an exception of type INDEX-OUT-OF-BOUNDS if 'pos' is not greater than or equal to zero or less than the size of 'str'. An exception of type INVALID-ARGUMENT is thrown if 'str' is not a string object or a string literal",
   "examples" : [ "(define x \"abc\") => \"abc\"", "(string-get x 0) => #\\a", "(string-get x 2) => #\\c" ],
   "see-also" : [ "array-get", "array-set", "string-set" ]
  },

  {"type" : 1, 
   "name" : "string-set", 
   "syntax" : "(string-set str pos val) => val",
   "args" : "str: a form that evaluates to a string; pos: an integer; val: a character",
   "desc" : "string-set sets the character at position 'pos' of 'str' to 'val'. Note that string indices start at zero",
   "exceptions" : "Throws an exception of type COMPILE-ERROR if no arguments are supplied. Throws an exception of type INDEX-OUT-OF-BOUNDS if 'pos' is not greater than or equal to zero or less than the size of 'str'. An exception of type INVALID-ARGUMENT is thrown if 'str' is not a string object or a string literal",
   "examples" : [ "(define x (string \"abc\")) => \"abc\"", "(string-set x 0 #\\d) => #\\d", "x => \"dbc\"" ],
   "see-also" : [ "array-get", "array-set", "string-get" ]
  },

  {"type" : 2, 
   "name" : "stringp", 
   "syntax" : "(stringp form) => result",
   "args" : "form: an object; result: T or NIL",
   "desc" : "stringp returns T if 'form' evaluates to a string object or a string literal and NIL otherwise",
   "exceptions" : "Throws an exception of type COMPILE-ERROR if no arguments are supplied",
   "examples" : [ "(stringp \"abc\") => T", "(stringp #\\a) => NIL" ],
   "see-also" : [  ]
  },

  {"type" : 2, 
   "name" : "sub-array", 
   "syntax" : "(sub-array arr start len) => result",
   "args" : "arr: a form that evaluates to an array; start, end: integers; result: an array",
   "desc" : "sub-array creates a new array comprising the elements starting from position 'start' in 'arr' till the position (start + len -1)",
   "exceptions" : "Throws an exception of type COMPILE-ERROR if the required number of  arguments is not supplied. An exception of type INVALID-ARGUMENT is thrown if the first argument is not an array or if the second and third arguments are not non-negative integers. Throws an exception of type INDEX-OUT-OF-BOUNDS if 'start' and 'len' specify a range outside the array size",
   "examples" : [ "(define x (make-array 5 nil)) => [NIL NIL NIL NIL NIL]", "(dolist (i '(0 1 2 3 4)) (array-set x i (+ i 1))) => NIL", "x => [1 2 3 4 5]", "(sub-array x 0 3) => [1 2 3]" ],
   "see-also" : [ "substring", "sub-list" ]
  },

  {"type" : 0, 
   "name" : "sub-list", 
   "syntax" : "(sub-list lst start len) => result",
   "args" : "lst: a form that evaluates to a list; start, end: integers; result: a list",
   "desc" : "sub-list creates a new list comprising the elements starting from position 'start' in 'lst' till the position (start + len -1)",
   "exceptions" : "Throws an exception of type COMPILE-ERROR if the required number of arguments is not supplied. An exception of type INVALID-ARGUMENT is thrown if the first argument is not a list or if the second and third arguments are not non-negative integers. Throws an exception of type INDEX-OUT-OF-BOUNDS if 'start' and 'len' specify a range outside the list size",
   "examples" : [ "(sub-list '(1 2 3 4 5) 0 3) => (1 2 3)" ],
   "see-also" : [ "substring", "sub-array" ]
  },

  {"type" : 1, 
   "name" : "substring", 
   "syntax" : "(substring str start len) => result",
   "args" : "str: a form that evaluates to a string; start, end: integers; result: a string",
   "desc" : "substring creates a new string comprising the elements starting from position 'start' in 'str' till the position (start + len -1)",
   "exceptions" : "Throws an exception of type COMPILE-ERROR if the required number of arguments is not supplied. An exception of type INVALID-ARGUMENT is thrown if the first argument is not an array (strings are internally stored as arrays in pLisp) or if the second and third arguments are not non-negative integers. Throws an exception of type INDEX-OUT-OF-BOUNDS if 'start' and 'len' specify a range outside the string size",
   "examples" : [ "(define x (make-string 3 #\\a)) => \"aaa\"", "x => \"aaa\"", "(substring x 0 2) => \"aa\"" ],
   "see-also" : [ "sub-array", "sub-list" ]
  },

  {"type" : 2, 
   "name" : "symbol", 
   "syntax" : "(symbol str) => result",
   "args" : "str: a form that evaluates to a string; result: a symbol",
   "desc" : "symbol returns the symbol object represented by 'str'. Note that this operator is case-insensitive",
   "exceptions" : "Throws an exception of type INVALID-ARGUMENT if no arguments are supplied or if the first argument is not a string",
   "examples" : [ "(symbol \"abc\") => ABC" ],
   "see-also" : [  ]
  },

  {"type" : 2, 
   "name" : "symbol-name", 
   "syntax" : "(symbol-name sym) => result",
   "args" : "sym: a form that evaluates to a symbol; result: a string",
   "desc" : "symbol returns the string representation of 'sym'",
   "exceptions" : "Throws an exception of type COMPILE-ERROR if no arguments are supplied. An exception of type INVALID-ARGUMENT is thrown if the first argument is not a symbol",
   "examples" : [ "(symbol-name 'abc) => \"ABC\"" ],
   "see-also" : [ "symbol-value" ]
  },

  {"type" : 2, 
   "name" : "symbol-value", 
   "syntax" : "(symbol-value sym) => result",
   "args" : "sym: a form that evaluates to a symbol; result: an object",
   "desc" : "symbol returns the object bound to 'sym' in the current environment",
   "exceptions" : "Throws an exception of type COMPILE-ERROR if no arguments are supplied. An exception of type INVALID-ARGUMENT is thrown if the first argument is not a symbol. Throws SYMBOL-NOT-BOUND if 'sym' is not bound to a value in the top-level environment",
   "examples" : [ "(define x 100) => 100", "(symbol-value 'x) => 100" ],
   "see-also" : [ "symbol-name" ]
  },

  {"type" : 2, 
   "name" : "symbolp", 
   "syntax" : "(symbolp form) => result",
   "args" : "form: an object; result: T or NIL",
   "desc" : "symbolp returns T if 'form' evaluates to a symbol and NIL otherwise",
   "exceptions" : "Throws an exception of type COMPILE-ERROR if no arguments are supplied",
   "examples" : [ "(symbolp 'x) => T", "(symbolp #\\a) => NIL" ],
   "see-also" : [  ]
  },

  {"type" : 1, 
   "name" : "third", 
   "syntax" : "(third lst) => result",
   "args" : "lst: a list; result: an object",
   "desc" : "third returns the third element of a list",
   "exceptions" : "Throws an exception of type COMPILE-ERROR if no arguments are supplied, and an exception of type NOT-A-CONS if 'lst' is not a list",
   "examples" : [ "(third '(1 2 3)) => 3", "(third ()) => NIL" ],
   "see-also" : [ "caar", "cadar", "cadddr", "caddr", "cadr", "car", "cdar", "cddr", "cdr", "first", "second", "fourth", "fifth" ]
  },

  {"type" : 2, 
   "name" : "throw", 
   "syntax" : "(throw ex) => NIL",
   "args" : "ex: an exception object",
   "desc" : "throw throws the exception object specified by 'ex'",
   "exceptions" : "Throws an exception of type COMPILE-ERROR if no arguments are supplied, and an exception of type INVALID-ARGUMENT if 'excp' is not a valid exception object",
   "examples" : [  ],
   "see-also" : [ "error" ]
  },

  {"type" : 2, 
   "name" : "time", 
   "syntax" : "(time exp) => NIL",
   "args" : "exp: a quoted form",
   "desc" : "time evaluates 'exp' and prints the time taken for the evaluation. The result is printed to the shell if pLisp was invoked with the '-c' option and to the Transcript if otherwise",
   "exceptions" : "Throws an EXCEPTION of type COMPILE-ERROR if no arguments are supplied. Propagates exceptions thrown (if any) by the compilation and evaluation of 'exp'",
   "examples" : [ "(time '(+ 1 1)) =>", "(+ 1 1) took 0 seconds 20 milliseconds", "2" ],
   "see-also" : [ "profile" ]
  },

  {"type" : 1, 
   "name" : "try", 
   "syntax" : "(try body exception-clause finally-clause) => result",
   "args" : "body, exception-clause, finally-clause: forms; result: an object",
   "desc" : "try evaluates 'body', and if any exceptions are thrown during this evaluation, evaluates 'exception-clause'. 'finally-clause' is evaluated irrespective of whether an exception is thrown",
   "exceptions" : "Throws an exception of type COMPILE-ERROR if no arguments are supplied or if 'exception-clause' is not of the form '(catch (ex) form)'. If the exception clause rethrows the exception (or throws a fresh exception), this exception is rethrown by the try",
   "examples" : [ "(try (car 1) (catch (e) \"Error!\") (print \"Done\")) =>", "\"Done\"", "\"Error!\"" ],
   "see-also" : [ "unwind-protect" ]
  },

  {"type" : 2, 
   "name" : "unbind", 
   "syntax" : "(unbind sym) => NIL",
   "args" : "sym: a qualified symbol",
   "desc" : "unbind unbinds 'sym' from the top level environment",
   "exceptions" : "Throws an exception of type COMPILE-ERROR if no arguments are supplied. An exception of type INVALID-ARGUMENT is thrown if the argument is not a symbol. Throws an exception of type SYMBOL-NOT-BOUND if the symbol was not bound already",
   "examples" : [ "(unbind 'user:x) => NIL" ],
   "see-also" : [ "define", "set", "setq" ]
  },

  {"type" : 1, 
   "name" : "unwind-protect", 
   "syntax" : "(unwind-protect body finally-clause) => result",
   "args" : "body, finally-clause: forms; result: an object",
   "desc" : "unwind-protect evaluates 'body', and if any exceptions are thrown during this evaluation, throws the exception. 'finally-clause' is evaluated before the exception is thrown",
   "exceptions" : "Throws an exception of type COMPILE-ERROR if the required number of arguments is not supplied. Rethrows any exception thrown during the evaluation of 'body'",
   "examples" : [ "(unwind-protect (car 1) (print \"Done\"))" ],
   "see-also" : [ "try" ]
  },

  {"type" : 1, 
   "name" : "values", 
   "syntax" : "(values &rest body) => result",
   "args" : "body: the arguments converted to a list; result: a list",
   "desc" : "values bundles the arguments into a list. It is used to return multiple values from an expression",
   "exceptions" : "None",
   "examples" : [ "(values 1 2 3) => (1 2 3)" ],
   "see-also" : [ "multiple-value-bind" ]
  },

  {"type" : 1, 
   "name" : "while", 
   "syntax" : "(while cond &rest body) => result",
   "args" : "cond: a form; body: the rest of the arguments converted to a list; result: an object",
   "desc" : "while evaluates 'body' while 'cond' evaluates to a non-NIL value. The result of evaluating 'body' for the last time is returned",
   "exceptions" : "Throws an exception of type COMPILE-ERROR if the required number of arguments is not supplied. Propagates exceptions (if any) thrown by its constituent forms",
   "examples" : [ "(let ((x 0)) (while (< x 5) (print x) (incf x))) =>", "0", "1", "2", "3", "4", "NIL" ],
   "see-also" : [  ]
  },

  {"type" : 2, 
   "name" : "-", 
   "syntax" : "(- form*) => result",
   "args" : "form: a form that evaluates to an integer or a float; result: an integer or a float",
   "desc" : "- subtracts the sum of the remaining arguments from the first argument",
   "exceptions" : "Throws an exception of type COMPILE-ERROR if at least two arguments are not supplied. An exception of type INVALID-ARGUMENT is thrown if any of the arguments is not an integer or a float",
   "examples" : [ "(- 2 1) => 1", "(- 10 2 3.14) => 4.860000" ],
   "see-also" : [  ]
  },

  {"type" : 2, 
   "name" : ",", 
   "syntax" : ",form => result",
   "args" : "form: a form; result: an object",
   "desc" : ", is used in macro bodies to represent forms whose values should be substituted in the compiled form",
   "exceptions" : "Throws an exception of type COMPILE-ERROR if invoked outside the context of function/macro definitions",
   "examples" : [ "(defmacro first (lst) `(car ,lst)) => <macro>" ],
   "see-also" : [  ]
  },

  {"type" : 2, 
   "name" : ",@", 
   "syntax" : ",@form => result",
   "args" : "form: a form; result: an object",
   "desc" : ",@ is used in macro bodies to splice the forms (whose values are lists) into a list in the compiled form",
   "exceptions" : "Throws an exception of type COMPILE-ERROR if invoked outside the context of function/macro definitions",
   "examples" : [ "(defmacro values (&rest body) `(list ,@body))" ],
   "see-also" : [  ]
  },

  {"type" : 2, 
   "name" : "*", 
   "syntax" : "(* form*) => result",
   "args" : "form: a form that evaluates to an integer or a float; result: an integer or a float",
   "desc" : "* multiplies all its arguments",
   "exceptions" : "Throws an exception of type COMPILE-ERROR if at least two arguments are not supplied. An exception of type INVALID-ARGUMENT is thrown if any of the arguments is not an integer or a float",
   "examples" : [ "(* 2 1) => 2", "(* 1 2 3) => 6" ],
   "see-also" : [  ]
  },

  {"type" : 2, 
   "name" : "/", 
   "syntax" : "(/ form*) => result",
   "args" : "form: a form that evaluates to an integer or a float; result: an integer or a float",
   "desc" : "/ divides the first argument by the product of the remaining arguments. If all the arguments are integers, integer division is performed, otherwise floating point division is performed",
   "exceptions" : "Throws an exception of type COMPILE-ERROR if at least two arguments are not supplied. An exception of type INVALID-ARGUMENT is thrown if any of the arguments is not an integer or a float. An exception DIV-BY-ZERO-EXCEPTION is thrown if a division by zero is attempted",
   "examples" : [ "(/ 2 1) => 2", "(/ 1.0 2 3) => 0.166667" ],
   "see-also" : [  ]
  },

  {"type" : 2, 
   "name" : "`", 
   "syntax" : "`form => result",
   "args" : "form: a form; result: an object",
   "desc" : "` is used in macro bodies to represent forms that should be carried over as-is to the compiled form",
   "exceptions" : "None",
   "examples" : [ "(defmacro first (lst) `(car ,lst)) => <macro>" ],
   "see-also" : [ "'" ]
  },

  {"type" : 2, 
   "name" : "'", 
   "syntax" : "'form => result",
   "args" : "form: a form; result: an object",
   "desc" : "' is used to quote a form, i.e. prevent pLisp from evaluating the form and instead return it as-is",
   "exceptions" : "None",
   "examples" : [ "'(a b c) => (a b c)" ],
   "see-also" : [ "`" ]
  },

  {"type" : 2, 
   "name" : "+", 
   "syntax" : "(+ form*) => result",
   "args" : "form: a form that evaluates to an integer or a float; result: an integer or a float",
   "desc" : "+ computes the sum of its arguments",
   "exceptions" : "Throws an exception of type COMPILE-ERROR if at least two arguments are not supplied. An exception of type INVALID-ARGUMENT is thrown if any of the arguments is not an integer or a float",
   "examples" : [ "(+ 1 2) => 3", "(+ 1 3.14) => 4.140000" ],
   "see-also" : [  ]
  },

  {"type" : 2, 
   "name" : "<", 
   "syntax" : "(< form1 form2) => result",
   "args" : "form1, form2: forms that evaluates to integers or floats; result: T or NIL",
   "desc" : "< returns T if 'form1' is less than 'form2' and NIL otherwise",
   "exceptions" : "Throws an exception of type COMPILE-ERROR if exactly two arguments are not supplied. An exception of type INVALID-ARGUMENT is thrown if either of the arguments is not an integer or a float",
   "examples" : [ "(< 1 2) => T", "(< 2 1) => NIL" ],
   "see-also" : [ "<=" ]
  },

  {"type" : 2, 
   "name" : "<=", 
   "syntax" : "(<= form1 form2) => result",
   "args" : "form1, form2: forms that evaluates to integers or floats; result: T or NIL",
   "desc" : "<= returns T if 'form1' is less than or equal to 'form2' and NIL otherwise",
   "exceptions" : "Throws an exception of type COMPILE-ERROR if exactly two arguments are not supplied. An exception of type INVALID-ARGUMENT is thrown if either of the arguments is not an integer or a float",
   "examples" : [ "(<= 1 2) => T", "(<= 2 2) => T", "(<= 4 3) => NIL" ],
   "see-also" : [ "<" ]
  },

  {"type" : 2, 
   "name" : ">", 
   "syntax" : "(> form1 form2) => result",
   "args" : "form1, form2: forms that evaluates to integers or floats; result: T or NIL",
   "desc" : "> returns T if 'form1' is greater than 'form2' and NIL otherwise",
   "exceptions" : "Throws an exception of type COMPILE-ERROR if exactly two arguments are not supplied. An exception of type INVALID-ARGUMENT is thrown if either of the arguments is not an integer or a float",
   "examples" : [ "(> 2 1) => T", "(> 2 7) => NIL" ],
   "see-also" : [ ">=" ]
  },

  {"type" : 2, 
   "name" : ">=", 
   "syntax" : "(>= form1 form2) => result",
   "args" : "form1, form2: forms that evaluates to integers or floats; result: T or NIL",
   "desc" : ">= returns T if 'form1' is greater than or equal to 'form2' and NIL otherwise",
   "exceptions" : "Throws an exception of type COMPILE-ERROR if exactly two arguments are not supplied. An exception of type INVALID-ARGUMENT is thrown if either of the arguments is not an integer or a float",
   "examples" : [ "(>= 7 2) => T", "(>= 1 2) => NIL", "(>= 1 1) => T" ],
   "see-also" : [ ">" ]
  }

 ]
}
